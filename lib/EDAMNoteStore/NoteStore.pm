#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use EDAMNoteStore::Types;

# HELPER FUNCTIONS AND STRUCTURES

package EDAMNoteStore::NoteStore_getSyncState_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getSyncState_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getSyncState_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getSyncState_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getSyncState_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getSyncState_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getSyncState_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMNoteStore::SyncState();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getSyncState_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getSyncChunk_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getSyncChunk_args->mk_accessors( qw( authenticationToken afterUSN maxEntries fullSyncOnly ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{afterUSN} = undef;
  $self->{maxEntries} = undef;
  $self->{fullSyncOnly} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{afterUSN}) {
      $self->{afterUSN} = $vals->{afterUSN};
    }
    if (defined $vals->{maxEntries}) {
      $self->{maxEntries} = $vals->{maxEntries};
    }
    if (defined $vals->{fullSyncOnly}) {
      $self->{fullSyncOnly} = $vals->{fullSyncOnly};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getSyncChunk_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{afterUSN});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{maxEntries});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{fullSyncOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getSyncChunk_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{afterUSN}) {
    $xfer += $output->writeFieldBegin('afterUSN', TType::I32, 2);
    $xfer += $output->writeI32($self->{afterUSN});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxEntries}) {
    $xfer += $output->writeFieldBegin('maxEntries', TType::I32, 3);
    $xfer += $output->writeI32($self->{maxEntries});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fullSyncOnly}) {
    $xfer += $output->writeFieldBegin('fullSyncOnly', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{fullSyncOnly});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getSyncChunk_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getSyncChunk_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getSyncChunk_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMNoteStore::SyncChunk();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getSyncChunk_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getFilteredSyncChunk_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getFilteredSyncChunk_args->mk_accessors( qw( authenticationToken afterUSN maxEntries filter ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{afterUSN} = undef;
  $self->{maxEntries} = undef;
  $self->{filter} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{afterUSN}) {
      $self->{afterUSN} = $vals->{afterUSN};
    }
    if (defined $vals->{maxEntries}) {
      $self->{maxEntries} = $vals->{maxEntries};
    }
    if (defined $vals->{filter}) {
      $self->{filter} = $vals->{filter};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getFilteredSyncChunk_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{afterUSN});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{maxEntries});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{filter} = new EDAMNoteStore::SyncChunkFilter();
        $xfer += $self->{filter}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getFilteredSyncChunk_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{afterUSN}) {
    $xfer += $output->writeFieldBegin('afterUSN', TType::I32, 2);
    $xfer += $output->writeI32($self->{afterUSN});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxEntries}) {
    $xfer += $output->writeFieldBegin('maxEntries', TType::I32, 3);
    $xfer += $output->writeI32($self->{maxEntries});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{filter}) {
    $xfer += $output->writeFieldBegin('filter', TType::STRUCT, 4);
    $xfer += $self->{filter}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getFilteredSyncChunk_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getFilteredSyncChunk_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getFilteredSyncChunk_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMNoteStore::SyncChunk();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getFilteredSyncChunk_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getLinkedNotebookSyncState_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getLinkedNotebookSyncState_args->mk_accessors( qw( authenticationToken linkedNotebook ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{linkedNotebook} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{linkedNotebook}) {
      $self->{linkedNotebook} = $vals->{linkedNotebook};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getLinkedNotebookSyncState_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{linkedNotebook} = new EDAMTypes::LinkedNotebook();
        $xfer += $self->{linkedNotebook}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getLinkedNotebookSyncState_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{linkedNotebook}) {
    $xfer += $output->writeFieldBegin('linkedNotebook', TType::STRUCT, 2);
    $xfer += $self->{linkedNotebook}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getLinkedNotebookSyncState_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getLinkedNotebookSyncState_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getLinkedNotebookSyncState_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMNoteStore::SyncState();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getLinkedNotebookSyncState_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getLinkedNotebookSyncChunk_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getLinkedNotebookSyncChunk_args->mk_accessors( qw( authenticationToken linkedNotebook afterUSN maxEntries fullSyncOnly ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{linkedNotebook} = undef;
  $self->{afterUSN} = undef;
  $self->{maxEntries} = undef;
  $self->{fullSyncOnly} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{linkedNotebook}) {
      $self->{linkedNotebook} = $vals->{linkedNotebook};
    }
    if (defined $vals->{afterUSN}) {
      $self->{afterUSN} = $vals->{afterUSN};
    }
    if (defined $vals->{maxEntries}) {
      $self->{maxEntries} = $vals->{maxEntries};
    }
    if (defined $vals->{fullSyncOnly}) {
      $self->{fullSyncOnly} = $vals->{fullSyncOnly};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getLinkedNotebookSyncChunk_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{linkedNotebook} = new EDAMTypes::LinkedNotebook();
        $xfer += $self->{linkedNotebook}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{afterUSN});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{maxEntries});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{fullSyncOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getLinkedNotebookSyncChunk_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{linkedNotebook}) {
    $xfer += $output->writeFieldBegin('linkedNotebook', TType::STRUCT, 2);
    $xfer += $self->{linkedNotebook}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{afterUSN}) {
    $xfer += $output->writeFieldBegin('afterUSN', TType::I32, 3);
    $xfer += $output->writeI32($self->{afterUSN});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxEntries}) {
    $xfer += $output->writeFieldBegin('maxEntries', TType::I32, 4);
    $xfer += $output->writeI32($self->{maxEntries});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fullSyncOnly}) {
    $xfer += $output->writeFieldBegin('fullSyncOnly', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{fullSyncOnly});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getLinkedNotebookSyncChunk_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getLinkedNotebookSyncChunk_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getLinkedNotebookSyncChunk_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMNoteStore::SyncChunk();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getLinkedNotebookSyncChunk_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listNotebooks_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listNotebooks_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listNotebooks_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listNotebooks_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listNotebooks_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listNotebooks_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listNotebooks_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size181 = 0;
          $self->{success} = [];
          my $_etype184 = 0;
          $xfer += $input->readListBegin(\$_etype184, \$_size181);
          for (my $_i185 = 0; $_i185 < $_size181; ++$_i185)
          {
            my $elem186 = undef;
            $elem186 = new EDAMTypes::Notebook();
            $xfer += $elem186->read($input);
            push(@{$self->{success}},$elem186);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listNotebooks_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter187 (@{$self->{success}}) 
        {
          $xfer += ${iter187}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNotebook_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNotebook_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Notebook();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getDefaultNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getDefaultNotebook_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getDefaultNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getDefaultNotebook_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getDefaultNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getDefaultNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getDefaultNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Notebook();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getDefaultNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createNotebook_args->mk_accessors( qw( authenticationToken notebook ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{notebook} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{notebook}) {
      $self->{notebook} = $vals->{notebook};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notebook} = new EDAMTypes::Notebook();
        $xfer += $self->{notebook}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createNotebook_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notebook}) {
    $xfer += $output->writeFieldBegin('notebook', TType::STRUCT, 2);
    $xfer += $self->{notebook}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Notebook();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateNotebook_args->mk_accessors( qw( authenticationToken notebook ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{notebook} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{notebook}) {
      $self->{notebook} = $vals->{notebook};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notebook} = new EDAMTypes::Notebook();
        $xfer += $self->{notebook}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateNotebook_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notebook}) {
    $xfer += $output->writeFieldBegin('notebook', TType::STRUCT, 2);
    $xfer += $self->{notebook}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeNotebook_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeNotebook_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listTags_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listTags_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listTags_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listTags_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listTags_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listTags_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listTags_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size188 = 0;
          $self->{success} = [];
          my $_etype191 = 0;
          $xfer += $input->readListBegin(\$_etype191, \$_size188);
          for (my $_i192 = 0; $_i192 < $_size188; ++$_i192)
          {
            my $elem193 = undef;
            $elem193 = new EDAMTypes::Tag();
            $xfer += $elem193->read($input);
            push(@{$self->{success}},$elem193);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listTags_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter194 (@{$self->{success}}) 
        {
          $xfer += ${iter194}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listTagsByNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listTagsByNotebook_args->mk_accessors( qw( authenticationToken notebookGuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{notebookGuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{notebookGuid}) {
      $self->{notebookGuid} = $vals->{notebookGuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listTagsByNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{notebookGuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listTagsByNotebook_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notebookGuid}) {
    $xfer += $output->writeFieldBegin('notebookGuid', TType::STRING, 2);
    $xfer += $output->writeString($self->{notebookGuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listTagsByNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listTagsByNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listTagsByNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size195 = 0;
          $self->{success} = [];
          my $_etype198 = 0;
          $xfer += $input->readListBegin(\$_etype198, \$_size195);
          for (my $_i199 = 0; $_i199 < $_size195; ++$_i199)
          {
            my $elem200 = undef;
            $elem200 = new EDAMTypes::Tag();
            $xfer += $elem200->read($input);
            push(@{$self->{success}},$elem200);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listTagsByNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter201 (@{$self->{success}}) 
        {
          $xfer += ${iter201}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getTag_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getTag_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getTag_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getTag_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getTag_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getTag_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getTag_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Tag();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getTag_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createTag_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createTag_args->mk_accessors( qw( authenticationToken tag ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{tag} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{tag}) {
      $self->{tag} = $vals->{tag};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createTag_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tag} = new EDAMTypes::Tag();
        $xfer += $self->{tag}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createTag_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tag}) {
    $xfer += $output->writeFieldBegin('tag', TType::STRUCT, 2);
    $xfer += $self->{tag}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createTag_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createTag_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createTag_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Tag();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createTag_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateTag_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateTag_args->mk_accessors( qw( authenticationToken tag ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{tag} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{tag}) {
      $self->{tag} = $vals->{tag};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateTag_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tag} = new EDAMTypes::Tag();
        $xfer += $self->{tag}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateTag_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tag}) {
    $xfer += $output->writeFieldBegin('tag', TType::STRUCT, 2);
    $xfer += $self->{tag}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateTag_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateTag_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateTag_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateTag_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_untagAll_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_untagAll_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_untagAll_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_untagAll_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_untagAll_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_untagAll_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_untagAll_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_untagAll_result');
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeTag_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeTag_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeTag_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeTag_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeTag_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeTag_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeTag_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeTag_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listSearches_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listSearches_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listSearches_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listSearches_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listSearches_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listSearches_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listSearches_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size202 = 0;
          $self->{success} = [];
          my $_etype205 = 0;
          $xfer += $input->readListBegin(\$_etype205, \$_size202);
          for (my $_i206 = 0; $_i206 < $_size202; ++$_i206)
          {
            my $elem207 = undef;
            $elem207 = new EDAMTypes::SavedSearch();
            $xfer += $elem207->read($input);
            push(@{$self->{success}},$elem207);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listSearches_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter208 (@{$self->{success}}) 
        {
          $xfer += ${iter208}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getSearch_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getSearch_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getSearch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getSearch_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getSearch_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getSearch_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getSearch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::SavedSearch();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getSearch_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createSearch_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createSearch_args->mk_accessors( qw( authenticationToken search ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{search} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{search}) {
      $self->{search} = $vals->{search};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createSearch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{search} = new EDAMTypes::SavedSearch();
        $xfer += $self->{search}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createSearch_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{search}) {
    $xfer += $output->writeFieldBegin('search', TType::STRUCT, 2);
    $xfer += $self->{search}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createSearch_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createSearch_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createSearch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::SavedSearch();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createSearch_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateSearch_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateSearch_args->mk_accessors( qw( authenticationToken search ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{search} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{search}) {
      $self->{search} = $vals->{search};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateSearch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{search} = new EDAMTypes::SavedSearch();
        $xfer += $self->{search}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateSearch_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{search}) {
    $xfer += $output->writeFieldBegin('search', TType::STRUCT, 2);
    $xfer += $self->{search}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateSearch_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateSearch_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateSearch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateSearch_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeSearch_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeSearch_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeSearch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeSearch_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeSearch_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeSearch_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeSearch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeSearch_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_findNotes_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_findNotes_args->mk_accessors( qw( authenticationToken filter offset maxNotes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{filter} = undef;
  $self->{offset} = undef;
  $self->{maxNotes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{filter}) {
      $self->{filter} = $vals->{filter};
    }
    if (defined $vals->{offset}) {
      $self->{offset} = $vals->{offset};
    }
    if (defined $vals->{maxNotes}) {
      $self->{maxNotes} = $vals->{maxNotes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_findNotes_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{filter} = new EDAMNoteStore::NoteFilter();
        $xfer += $self->{filter}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{offset});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{maxNotes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_findNotes_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{filter}) {
    $xfer += $output->writeFieldBegin('filter', TType::STRUCT, 2);
    $xfer += $self->{filter}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{offset}) {
    $xfer += $output->writeFieldBegin('offset', TType::I32, 3);
    $xfer += $output->writeI32($self->{offset});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxNotes}) {
    $xfer += $output->writeFieldBegin('maxNotes', TType::I32, 4);
    $xfer += $output->writeI32($self->{maxNotes});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_findNotes_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_findNotes_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_findNotes_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMNoteStore::NoteList();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_findNotes_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_findNoteOffset_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_findNoteOffset_args->mk_accessors( qw( authenticationToken filter guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{filter} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{filter}) {
      $self->{filter} = $vals->{filter};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_findNoteOffset_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{filter} = new EDAMNoteStore::NoteFilter();
        $xfer += $self->{filter}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_findNoteOffset_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{filter}) {
    $xfer += $output->writeFieldBegin('filter', TType::STRUCT, 2);
    $xfer += $self->{filter}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 3);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_findNoteOffset_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_findNoteOffset_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_findNoteOffset_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_findNoteOffset_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_findNotesMetadata_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_findNotesMetadata_args->mk_accessors( qw( authenticationToken filter offset maxNotes resultSpec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{filter} = undef;
  $self->{offset} = undef;
  $self->{maxNotes} = undef;
  $self->{resultSpec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{filter}) {
      $self->{filter} = $vals->{filter};
    }
    if (defined $vals->{offset}) {
      $self->{offset} = $vals->{offset};
    }
    if (defined $vals->{maxNotes}) {
      $self->{maxNotes} = $vals->{maxNotes};
    }
    if (defined $vals->{resultSpec}) {
      $self->{resultSpec} = $vals->{resultSpec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_findNotesMetadata_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{filter} = new EDAMNoteStore::NoteFilter();
        $xfer += $self->{filter}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{offset});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{maxNotes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{resultSpec} = new EDAMNoteStore::NotesMetadataResultSpec();
        $xfer += $self->{resultSpec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_findNotesMetadata_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{filter}) {
    $xfer += $output->writeFieldBegin('filter', TType::STRUCT, 2);
    $xfer += $self->{filter}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{offset}) {
    $xfer += $output->writeFieldBegin('offset', TType::I32, 3);
    $xfer += $output->writeI32($self->{offset});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxNotes}) {
    $xfer += $output->writeFieldBegin('maxNotes', TType::I32, 4);
    $xfer += $output->writeI32($self->{maxNotes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{resultSpec}) {
    $xfer += $output->writeFieldBegin('resultSpec', TType::STRUCT, 5);
    $xfer += $self->{resultSpec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_findNotesMetadata_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_findNotesMetadata_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_findNotesMetadata_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMNoteStore::NotesMetadataList();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_findNotesMetadata_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_findNoteCounts_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_findNoteCounts_args->mk_accessors( qw( authenticationToken filter withTrash ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{filter} = undef;
  $self->{withTrash} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{filter}) {
      $self->{filter} = $vals->{filter};
    }
    if (defined $vals->{withTrash}) {
      $self->{withTrash} = $vals->{withTrash};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_findNoteCounts_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{filter} = new EDAMNoteStore::NoteFilter();
        $xfer += $self->{filter}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withTrash});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_findNoteCounts_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{filter}) {
    $xfer += $output->writeFieldBegin('filter', TType::STRUCT, 2);
    $xfer += $self->{filter}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withTrash}) {
    $xfer += $output->writeFieldBegin('withTrash', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{withTrash});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_findNoteCounts_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_findNoteCounts_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_findNoteCounts_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMNoteStore::NoteCollectionCounts();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_findNoteCounts_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNote_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNote_args->mk_accessors( qw( authenticationToken guid withContent withResourcesData withResourcesRecognition withResourcesAlternateData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  $self->{withContent} = undef;
  $self->{withResourcesData} = undef;
  $self->{withResourcesRecognition} = undef;
  $self->{withResourcesAlternateData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{withContent}) {
      $self->{withContent} = $vals->{withContent};
    }
    if (defined $vals->{withResourcesData}) {
      $self->{withResourcesData} = $vals->{withResourcesData};
    }
    if (defined $vals->{withResourcesRecognition}) {
      $self->{withResourcesRecognition} = $vals->{withResourcesRecognition};
    }
    if (defined $vals->{withResourcesAlternateData}) {
      $self->{withResourcesAlternateData} = $vals->{withResourcesAlternateData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNote_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withContent});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withResourcesData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withResourcesRecognition});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withResourcesAlternateData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNote_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withContent}) {
    $xfer += $output->writeFieldBegin('withContent', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{withContent});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withResourcesData}) {
    $xfer += $output->writeFieldBegin('withResourcesData', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{withResourcesData});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withResourcesRecognition}) {
    $xfer += $output->writeFieldBegin('withResourcesRecognition', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{withResourcesRecognition});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withResourcesAlternateData}) {
    $xfer += $output->writeFieldBegin('withResourcesAlternateData', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{withResourcesAlternateData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNote_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNote_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNote_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Note();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNote_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteApplicationData_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteApplicationData_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteApplicationData_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteApplicationData_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteApplicationData_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteApplicationData_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteApplicationData_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::LazyMap();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteApplicationData_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteApplicationDataEntry_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteApplicationDataEntry_args->mk_accessors( qw( authenticationToken guid key ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  $self->{key} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteApplicationDataEntry_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteApplicationDataEntry_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 3);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteApplicationDataEntry_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteApplicationDataEntry_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteApplicationDataEntry_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteApplicationDataEntry_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_setNoteApplicationDataEntry_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_setNoteApplicationDataEntry_args->mk_accessors( qw( authenticationToken guid key value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  $self->{key} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_setNoteApplicationDataEntry_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_setNoteApplicationDataEntry_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 3);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_setNoteApplicationDataEntry_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_setNoteApplicationDataEntry_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_setNoteApplicationDataEntry_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_setNoteApplicationDataEntry_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_unsetNoteApplicationDataEntry_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_unsetNoteApplicationDataEntry_args->mk_accessors( qw( authenticationToken guid key ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  $self->{key} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_unsetNoteApplicationDataEntry_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_unsetNoteApplicationDataEntry_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 3);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_unsetNoteApplicationDataEntry_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_unsetNoteApplicationDataEntry_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_unsetNoteApplicationDataEntry_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_unsetNoteApplicationDataEntry_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteContent_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteContent_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteContent_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteContent_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteContent_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteContent_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteContent_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteContent_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteSearchText_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteSearchText_args->mk_accessors( qw( authenticationToken guid noteOnly tokenizeForIndexing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  $self->{noteOnly} = undef;
  $self->{tokenizeForIndexing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{noteOnly}) {
      $self->{noteOnly} = $vals->{noteOnly};
    }
    if (defined $vals->{tokenizeForIndexing}) {
      $self->{tokenizeForIndexing} = $vals->{tokenizeForIndexing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteSearchText_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{noteOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{tokenizeForIndexing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteSearchText_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{noteOnly}) {
    $xfer += $output->writeFieldBegin('noteOnly', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{noteOnly});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenizeForIndexing}) {
    $xfer += $output->writeFieldBegin('tokenizeForIndexing', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{tokenizeForIndexing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteSearchText_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteSearchText_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteSearchText_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteSearchText_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceSearchText_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceSearchText_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceSearchText_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceSearchText_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceSearchText_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceSearchText_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceSearchText_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceSearchText_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteTagNames_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteTagNames_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteTagNames_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteTagNames_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteTagNames_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteTagNames_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteTagNames_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size209 = 0;
          $self->{success} = [];
          my $_etype212 = 0;
          $xfer += $input->readListBegin(\$_etype212, \$_size209);
          for (my $_i213 = 0; $_i213 < $_size209; ++$_i213)
          {
            my $elem214 = undef;
            $xfer += $input->readString(\$elem214);
            push(@{$self->{success}},$elem214);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteTagNames_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter215 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter215);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createNote_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createNote_args->mk_accessors( qw( authenticationToken note ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{note} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{note}) {
      $self->{note} = $vals->{note};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createNote_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{note} = new EDAMTypes::Note();
        $xfer += $self->{note}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createNote_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{note}) {
    $xfer += $output->writeFieldBegin('note', TType::STRUCT, 2);
    $xfer += $self->{note}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createNote_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createNote_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createNote_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Note();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createNote_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateNote_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateNote_args->mk_accessors( qw( authenticationToken note ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{note} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{note}) {
      $self->{note} = $vals->{note};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateNote_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{note} = new EDAMTypes::Note();
        $xfer += $self->{note}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateNote_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{note}) {
    $xfer += $output->writeFieldBegin('note', TType::STRUCT, 2);
    $xfer += $self->{note}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateNote_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateNote_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateNote_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Note();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateNote_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_deleteNote_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_deleteNote_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_deleteNote_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_deleteNote_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_deleteNote_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_deleteNote_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_deleteNote_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_deleteNote_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeNote_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeNote_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeNote_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeNote_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeNote_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeNote_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeNote_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeNote_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeNotes_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeNotes_args->mk_accessors( qw( authenticationToken noteGuids ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{noteGuids} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{noteGuids}) {
      $self->{noteGuids} = $vals->{noteGuids};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeNotes_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size216 = 0;
          $self->{noteGuids} = [];
          my $_etype219 = 0;
          $xfer += $input->readListBegin(\$_etype219, \$_size216);
          for (my $_i220 = 0; $_i220 < $_size216; ++$_i220)
          {
            my $elem221 = undef;
            $xfer += $input->readString(\$elem221);
            push(@{$self->{noteGuids}},$elem221);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeNotes_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{noteGuids}) {
    $xfer += $output->writeFieldBegin('noteGuids', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{noteGuids}}));
      {
        foreach my $iter222 (@{$self->{noteGuids}}) 
        {
          $xfer += $output->writeString($iter222);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeNotes_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeNotes_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeNotes_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeNotes_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeInactiveNotes_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeInactiveNotes_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeInactiveNotes_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeInactiveNotes_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeInactiveNotes_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeInactiveNotes_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeInactiveNotes_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeInactiveNotes_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_copyNote_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_copyNote_args->mk_accessors( qw( authenticationToken noteGuid toNotebookGuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{noteGuid} = undef;
  $self->{toNotebookGuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{noteGuid}) {
      $self->{noteGuid} = $vals->{noteGuid};
    }
    if (defined $vals->{toNotebookGuid}) {
      $self->{toNotebookGuid} = $vals->{toNotebookGuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_copyNote_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{noteGuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{toNotebookGuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_copyNote_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{noteGuid}) {
    $xfer += $output->writeFieldBegin('noteGuid', TType::STRING, 2);
    $xfer += $output->writeString($self->{noteGuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{toNotebookGuid}) {
    $xfer += $output->writeFieldBegin('toNotebookGuid', TType::STRING, 3);
    $xfer += $output->writeString($self->{toNotebookGuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_copyNote_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_copyNote_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_copyNote_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Note();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_copyNote_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listNoteVersions_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listNoteVersions_args->mk_accessors( qw( authenticationToken noteGuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{noteGuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{noteGuid}) {
      $self->{noteGuid} = $vals->{noteGuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listNoteVersions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{noteGuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listNoteVersions_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{noteGuid}) {
    $xfer += $output->writeFieldBegin('noteGuid', TType::STRING, 2);
    $xfer += $output->writeString($self->{noteGuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listNoteVersions_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listNoteVersions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listNoteVersions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size223 = 0;
          $self->{success} = [];
          my $_etype226 = 0;
          $xfer += $input->readListBegin(\$_etype226, \$_size223);
          for (my $_i227 = 0; $_i227 < $_size223; ++$_i227)
          {
            my $elem228 = undef;
            $elem228 = new EDAMNoteStore::NoteVersionId();
            $xfer += $elem228->read($input);
            push(@{$self->{success}},$elem228);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listNoteVersions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter229 (@{$self->{success}}) 
        {
          $xfer += ${iter229}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteVersion_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteVersion_args->mk_accessors( qw( authenticationToken noteGuid updateSequenceNum withResourcesData withResourcesRecognition withResourcesAlternateData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{noteGuid} = undef;
  $self->{updateSequenceNum} = undef;
  $self->{withResourcesData} = undef;
  $self->{withResourcesRecognition} = undef;
  $self->{withResourcesAlternateData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{noteGuid}) {
      $self->{noteGuid} = $vals->{noteGuid};
    }
    if (defined $vals->{updateSequenceNum}) {
      $self->{updateSequenceNum} = $vals->{updateSequenceNum};
    }
    if (defined $vals->{withResourcesData}) {
      $self->{withResourcesData} = $vals->{withResourcesData};
    }
    if (defined $vals->{withResourcesRecognition}) {
      $self->{withResourcesRecognition} = $vals->{withResourcesRecognition};
    }
    if (defined $vals->{withResourcesAlternateData}) {
      $self->{withResourcesAlternateData} = $vals->{withResourcesAlternateData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteVersion_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{noteGuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{updateSequenceNum});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withResourcesData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withResourcesRecognition});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withResourcesAlternateData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteVersion_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{noteGuid}) {
    $xfer += $output->writeFieldBegin('noteGuid', TType::STRING, 2);
    $xfer += $output->writeString($self->{noteGuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updateSequenceNum}) {
    $xfer += $output->writeFieldBegin('updateSequenceNum', TType::I32, 3);
    $xfer += $output->writeI32($self->{updateSequenceNum});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withResourcesData}) {
    $xfer += $output->writeFieldBegin('withResourcesData', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{withResourcesData});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withResourcesRecognition}) {
    $xfer += $output->writeFieldBegin('withResourcesRecognition', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{withResourcesRecognition});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withResourcesAlternateData}) {
    $xfer += $output->writeFieldBegin('withResourcesAlternateData', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{withResourcesAlternateData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getNoteVersion_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getNoteVersion_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getNoteVersion_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Note();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getNoteVersion_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResource_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResource_args->mk_accessors( qw( authenticationToken guid withData withRecognition withAttributes withAlternateData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  $self->{withData} = undef;
  $self->{withRecognition} = undef;
  $self->{withAttributes} = undef;
  $self->{withAlternateData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{withData}) {
      $self->{withData} = $vals->{withData};
    }
    if (defined $vals->{withRecognition}) {
      $self->{withRecognition} = $vals->{withRecognition};
    }
    if (defined $vals->{withAttributes}) {
      $self->{withAttributes} = $vals->{withAttributes};
    }
    if (defined $vals->{withAlternateData}) {
      $self->{withAlternateData} = $vals->{withAlternateData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResource_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withRecognition});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withAttributes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withAlternateData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResource_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withData}) {
    $xfer += $output->writeFieldBegin('withData', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{withData});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withRecognition}) {
    $xfer += $output->writeFieldBegin('withRecognition', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{withRecognition});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withAttributes}) {
    $xfer += $output->writeFieldBegin('withAttributes', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{withAttributes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withAlternateData}) {
    $xfer += $output->writeFieldBegin('withAlternateData', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{withAlternateData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResource_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResource_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResource_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Resource();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResource_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceApplicationData_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceApplicationData_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceApplicationData_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceApplicationData_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceApplicationData_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceApplicationData_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceApplicationData_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::LazyMap();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceApplicationData_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceApplicationDataEntry_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceApplicationDataEntry_args->mk_accessors( qw( authenticationToken guid key ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  $self->{key} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceApplicationDataEntry_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceApplicationDataEntry_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 3);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceApplicationDataEntry_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceApplicationDataEntry_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceApplicationDataEntry_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceApplicationDataEntry_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_setResourceApplicationDataEntry_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_setResourceApplicationDataEntry_args->mk_accessors( qw( authenticationToken guid key value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  $self->{key} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_setResourceApplicationDataEntry_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_setResourceApplicationDataEntry_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 3);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_setResourceApplicationDataEntry_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_setResourceApplicationDataEntry_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_setResourceApplicationDataEntry_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_setResourceApplicationDataEntry_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_unsetResourceApplicationDataEntry_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_unsetResourceApplicationDataEntry_args->mk_accessors( qw( authenticationToken guid key ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  $self->{key} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_unsetResourceApplicationDataEntry_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_unsetResourceApplicationDataEntry_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 3);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_unsetResourceApplicationDataEntry_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_unsetResourceApplicationDataEntry_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_unsetResourceApplicationDataEntry_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_unsetResourceApplicationDataEntry_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateResource_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateResource_args->mk_accessors( qw( authenticationToken resource ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{resource} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{resource}) {
      $self->{resource} = $vals->{resource};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateResource_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{resource} = new EDAMTypes::Resource();
        $xfer += $self->{resource}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateResource_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{resource}) {
    $xfer += $output->writeFieldBegin('resource', TType::STRUCT, 2);
    $xfer += $self->{resource}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateResource_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateResource_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateResource_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateResource_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceData_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceData_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceData_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceData_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceData_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceData_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceData_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceData_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceByHash_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceByHash_args->mk_accessors( qw( authenticationToken noteGuid contentHash withData withRecognition withAlternateData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{noteGuid} = undef;
  $self->{contentHash} = undef;
  $self->{withData} = undef;
  $self->{withRecognition} = undef;
  $self->{withAlternateData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{noteGuid}) {
      $self->{noteGuid} = $vals->{noteGuid};
    }
    if (defined $vals->{contentHash}) {
      $self->{contentHash} = $vals->{contentHash};
    }
    if (defined $vals->{withData}) {
      $self->{withData} = $vals->{withData};
    }
    if (defined $vals->{withRecognition}) {
      $self->{withRecognition} = $vals->{withRecognition};
    }
    if (defined $vals->{withAlternateData}) {
      $self->{withAlternateData} = $vals->{withAlternateData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceByHash_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{noteGuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{contentHash});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withRecognition});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{withAlternateData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceByHash_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{noteGuid}) {
    $xfer += $output->writeFieldBegin('noteGuid', TType::STRING, 2);
    $xfer += $output->writeString($self->{noteGuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{contentHash}) {
    $xfer += $output->writeFieldBegin('contentHash', TType::STRING, 3);
    $xfer += $output->writeString($self->{contentHash});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withData}) {
    $xfer += $output->writeFieldBegin('withData', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{withData});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withRecognition}) {
    $xfer += $output->writeFieldBegin('withRecognition', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{withRecognition});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{withAlternateData}) {
    $xfer += $output->writeFieldBegin('withAlternateData', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{withAlternateData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceByHash_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceByHash_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceByHash_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Resource();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceByHash_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceRecognition_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceRecognition_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceRecognition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceRecognition_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceRecognition_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceRecognition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceRecognition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceRecognition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceAlternateData_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceAlternateData_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceAlternateData_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceAlternateData_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceAlternateData_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceAlternateData_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceAlternateData_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceAlternateData_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceAttributes_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceAttributes_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceAttributes_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceAttributes_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getResourceAttributes_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getResourceAttributes_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getResourceAttributes_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::ResourceAttributes();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getResourceAttributes_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 3);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getAccountSize_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getAccountSize_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getAccountSize_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getAccountSize_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getAccountSize_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getAccountSize_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getAccountSize_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getAccountSize_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getAds_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getAds_args->mk_accessors( qw( authenticationToken adParameters ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{adParameters} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{adParameters}) {
      $self->{adParameters} = $vals->{adParameters};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getAds_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{adParameters} = new EDAMNoteStore::AdParameters();
        $xfer += $self->{adParameters}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getAds_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{adParameters}) {
    $xfer += $output->writeFieldBegin('adParameters', TType::STRUCT, 2);
    $xfer += $self->{adParameters}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getAds_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getAds_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getAds_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size230 = 0;
          $self->{success} = [];
          my $_etype233 = 0;
          $xfer += $input->readListBegin(\$_etype233, \$_size230);
          for (my $_i234 = 0; $_i234 < $_size230; ++$_i234)
          {
            my $elem235 = undef;
            $elem235 = new EDAMTypes::Ad();
            $xfer += $elem235->read($input);
            push(@{$self->{success}},$elem235);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getAds_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter236 (@{$self->{success}}) 
        {
          $xfer += ${iter236}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getRandomAd_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getRandomAd_args->mk_accessors( qw( authenticationToken adParameters ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{adParameters} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{adParameters}) {
      $self->{adParameters} = $vals->{adParameters};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getRandomAd_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{adParameters} = new EDAMNoteStore::AdParameters();
        $xfer += $self->{adParameters}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getRandomAd_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{adParameters}) {
    $xfer += $output->writeFieldBegin('adParameters', TType::STRUCT, 2);
    $xfer += $self->{adParameters}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getRandomAd_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getRandomAd_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getRandomAd_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Ad();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getRandomAd_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getPublicNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getPublicNotebook_args->mk_accessors( qw( userId publicUri ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{userId} = undef;
  $self->{publicUri} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{userId}) {
      $self->{userId} = $vals->{userId};
    }
    if (defined $vals->{publicUri}) {
      $self->{publicUri} = $vals->{publicUri};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getPublicNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{userId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{publicUri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getPublicNotebook_args');
  if (defined $self->{userId}) {
    $xfer += $output->writeFieldBegin('userId', TType::I32, 1);
    $xfer += $output->writeI32($self->{userId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{publicUri}) {
    $xfer += $output->writeFieldBegin('publicUri', TType::STRING, 2);
    $xfer += $output->writeString($self->{publicUri});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getPublicNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getPublicNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{systemException} = undef;
  $self->{notFoundException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getPublicNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::Notebook();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getPublicNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 1);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createSharedNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createSharedNotebook_args->mk_accessors( qw( authenticationToken sharedNotebook ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{sharedNotebook} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{sharedNotebook}) {
      $self->{sharedNotebook} = $vals->{sharedNotebook};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createSharedNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sharedNotebook} = new EDAMTypes::SharedNotebook();
        $xfer += $self->{sharedNotebook}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createSharedNotebook_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sharedNotebook}) {
    $xfer += $output->writeFieldBegin('sharedNotebook', TType::STRUCT, 2);
    $xfer += $self->{sharedNotebook}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createSharedNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createSharedNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createSharedNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::SharedNotebook();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createSharedNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_sendMessageToSharedNotebookMembers_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_sendMessageToSharedNotebookMembers_args->mk_accessors( qw( authenticationToken notebookGuid messageText recipients ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{notebookGuid} = undef;
  $self->{messageText} = undef;
  $self->{recipients} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{notebookGuid}) {
      $self->{notebookGuid} = $vals->{notebookGuid};
    }
    if (defined $vals->{messageText}) {
      $self->{messageText} = $vals->{messageText};
    }
    if (defined $vals->{recipients}) {
      $self->{recipients} = $vals->{recipients};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_sendMessageToSharedNotebookMembers_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{notebookGuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{messageText});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size237 = 0;
          $self->{recipients} = [];
          my $_etype240 = 0;
          $xfer += $input->readListBegin(\$_etype240, \$_size237);
          for (my $_i241 = 0; $_i241 < $_size237; ++$_i241)
          {
            my $elem242 = undef;
            $xfer += $input->readString(\$elem242);
            push(@{$self->{recipients}},$elem242);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_sendMessageToSharedNotebookMembers_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notebookGuid}) {
    $xfer += $output->writeFieldBegin('notebookGuid', TType::STRING, 2);
    $xfer += $output->writeString($self->{notebookGuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{messageText}) {
    $xfer += $output->writeFieldBegin('messageText', TType::STRING, 3);
    $xfer += $output->writeString($self->{messageText});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recipients}) {
    $xfer += $output->writeFieldBegin('recipients', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{recipients}}));
      {
        foreach my $iter243 (@{$self->{recipients}}) 
        {
          $xfer += $output->writeString($iter243);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_sendMessageToSharedNotebookMembers_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_sendMessageToSharedNotebookMembers_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_sendMessageToSharedNotebookMembers_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_sendMessageToSharedNotebookMembers_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listSharedNotebooks_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listSharedNotebooks_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listSharedNotebooks_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listSharedNotebooks_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listSharedNotebooks_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listSharedNotebooks_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listSharedNotebooks_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size244 = 0;
          $self->{success} = [];
          my $_etype247 = 0;
          $xfer += $input->readListBegin(\$_etype247, \$_size244);
          for (my $_i248 = 0; $_i248 < $_size244; ++$_i248)
          {
            my $elem249 = undef;
            $elem249 = new EDAMTypes::SharedNotebook();
            $xfer += $elem249->read($input);
            push(@{$self->{success}},$elem249);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listSharedNotebooks_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter250 (@{$self->{success}}) 
        {
          $xfer += ${iter250}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeSharedNotebooks_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeSharedNotebooks_args->mk_accessors( qw( authenticationToken sharedNotebookIds ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{sharedNotebookIds} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{sharedNotebookIds}) {
      $self->{sharedNotebookIds} = $vals->{sharedNotebookIds};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeSharedNotebooks_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size251 = 0;
          $self->{sharedNotebookIds} = [];
          my $_etype254 = 0;
          $xfer += $input->readListBegin(\$_etype254, \$_size251);
          for (my $_i255 = 0; $_i255 < $_size251; ++$_i255)
          {
            my $elem256 = undef;
            $xfer += $input->readI64(\$elem256);
            push(@{$self->{sharedNotebookIds}},$elem256);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeSharedNotebooks_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sharedNotebookIds}) {
    $xfer += $output->writeFieldBegin('sharedNotebookIds', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::I64, scalar(@{$self->{sharedNotebookIds}}));
      {
        foreach my $iter257 (@{$self->{sharedNotebookIds}}) 
        {
          $xfer += $output->writeI64($iter257);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeSharedNotebooks_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeSharedNotebooks_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeSharedNotebooks_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeSharedNotebooks_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createLinkedNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createLinkedNotebook_args->mk_accessors( qw( authenticationToken linkedNotebook ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{linkedNotebook} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{linkedNotebook}) {
      $self->{linkedNotebook} = $vals->{linkedNotebook};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createLinkedNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{linkedNotebook} = new EDAMTypes::LinkedNotebook();
        $xfer += $self->{linkedNotebook}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createLinkedNotebook_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{linkedNotebook}) {
    $xfer += $output->writeFieldBegin('linkedNotebook', TType::STRUCT, 2);
    $xfer += $self->{linkedNotebook}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_createLinkedNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_createLinkedNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_createLinkedNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::LinkedNotebook();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_createLinkedNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateLinkedNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateLinkedNotebook_args->mk_accessors( qw( authenticationToken linkedNotebook ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{linkedNotebook} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{linkedNotebook}) {
      $self->{linkedNotebook} = $vals->{linkedNotebook};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateLinkedNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{linkedNotebook} = new EDAMTypes::LinkedNotebook();
        $xfer += $self->{linkedNotebook}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateLinkedNotebook_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{linkedNotebook}) {
    $xfer += $output->writeFieldBegin('linkedNotebook', TType::STRUCT, 2);
    $xfer += $self->{linkedNotebook}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_updateLinkedNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_updateLinkedNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_updateLinkedNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_updateLinkedNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listLinkedNotebooks_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listLinkedNotebooks_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listLinkedNotebooks_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listLinkedNotebooks_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_listLinkedNotebooks_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_listLinkedNotebooks_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_listLinkedNotebooks_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size258 = 0;
          $self->{success} = [];
          my $_etype261 = 0;
          $xfer += $input->readListBegin(\$_etype261, \$_size258);
          for (my $_i262 = 0; $_i262 < $_size258; ++$_i262)
          {
            my $elem263 = undef;
            $elem263 = new EDAMTypes::LinkedNotebook();
            $xfer += $elem263->read($input);
            push(@{$self->{success}},$elem263);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_listLinkedNotebooks_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter264 (@{$self->{success}}) 
        {
          $xfer += ${iter264}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeLinkedNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeLinkedNotebook_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeLinkedNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeLinkedNotebook_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_expungeLinkedNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_expungeLinkedNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_expungeLinkedNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_expungeLinkedNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_authenticateToSharedNotebook_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_authenticateToSharedNotebook_args->mk_accessors( qw( shareKey authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{shareKey} = undef;
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{shareKey}) {
      $self->{shareKey} = $vals->{shareKey};
    }
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_authenticateToSharedNotebook_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{shareKey});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_authenticateToSharedNotebook_args');
  if (defined $self->{shareKey}) {
    $xfer += $output->writeFieldBegin('shareKey', TType::STRING, 1);
    $xfer += $output->writeString($self->{shareKey});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 2);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_authenticateToSharedNotebook_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_authenticateToSharedNotebook_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_authenticateToSharedNotebook_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMUserStore::AuthenticationResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_authenticateToSharedNotebook_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getSharedNotebookByAuth_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getSharedNotebookByAuth_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getSharedNotebookByAuth_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getSharedNotebookByAuth_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_getSharedNotebookByAuth_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_getSharedNotebookByAuth_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_getSharedNotebookByAuth_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::SharedNotebook();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_getSharedNotebookByAuth_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_emailNote_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_emailNote_args->mk_accessors( qw( authenticationToken parameters ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{parameters} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_emailNote_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{parameters} = new EDAMNoteStore::NoteEmailParameters();
        $xfer += $self->{parameters}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_emailNote_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::STRUCT, 2);
    $xfer += $self->{parameters}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_emailNote_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_emailNote_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_emailNote_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_emailNote_result');
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_shareNote_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_shareNote_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_shareNote_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_shareNote_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_shareNote_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_shareNote_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_shareNote_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_shareNote_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_stopSharingNote_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_stopSharingNote_args->mk_accessors( qw( authenticationToken guid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{guid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_stopSharingNote_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_stopSharingNote_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 2);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_stopSharingNote_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_stopSharingNote_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_stopSharingNote_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_stopSharingNote_result');
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_authenticateToSharedNote_args;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_authenticateToSharedNote_args->mk_accessors( qw( guid noteKey ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{guid} = undef;
  $self->{noteKey} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{noteKey}) {
      $self->{noteKey} = $vals->{noteKey};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_authenticateToSharedNote_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{noteKey});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_authenticateToSharedNote_args');
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 1);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{noteKey}) {
    $xfer += $output->writeFieldBegin('noteKey', TType::STRING, 2);
    $xfer += $output->writeString($self->{noteKey});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStore_authenticateToSharedNote_result;
use base qw(Class::Accessor);
EDAMNoteStore::NoteStore_authenticateToSharedNote_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteStore_authenticateToSharedNote_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMUserStore::AuthenticationResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteStore_authenticateToSharedNote_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 2);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 3);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteStoreIf;

use strict;


sub getSyncState{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub getSyncChunk{
  my $self = shift;
  my $authenticationToken = shift;
  my $afterUSN = shift;
  my $maxEntries = shift;
  my $fullSyncOnly = shift;

  die 'implement interface';
}

sub getFilteredSyncChunk{
  my $self = shift;
  my $authenticationToken = shift;
  my $afterUSN = shift;
  my $maxEntries = shift;
  my $filter = shift;

  die 'implement interface';
}

sub getLinkedNotebookSyncState{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;

  die 'implement interface';
}

sub getLinkedNotebookSyncChunk{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;
  my $afterUSN = shift;
  my $maxEntries = shift;
  my $fullSyncOnly = shift;

  die 'implement interface';
}

sub listNotebooks{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub getNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub getDefaultNotebook{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub createNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebook = shift;

  die 'implement interface';
}

sub updateNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebook = shift;

  die 'implement interface';
}

sub expungeNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub listTags{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub listTagsByNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebookGuid = shift;

  die 'implement interface';
}

sub getTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub createTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $tag = shift;

  die 'implement interface';
}

sub updateTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $tag = shift;

  die 'implement interface';
}

sub untagAll{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub expungeTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub listSearches{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub getSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub createSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $search = shift;

  die 'implement interface';
}

sub updateSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $search = shift;

  die 'implement interface';
}

sub expungeSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub findNotes{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $offset = shift;
  my $maxNotes = shift;

  die 'implement interface';
}

sub findNoteOffset{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $guid = shift;

  die 'implement interface';
}

sub findNotesMetadata{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $offset = shift;
  my $maxNotes = shift;
  my $resultSpec = shift;

  die 'implement interface';
}

sub findNoteCounts{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $withTrash = shift;

  die 'implement interface';
}

sub getNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $withContent = shift;
  my $withResourcesData = shift;
  my $withResourcesRecognition = shift;
  my $withResourcesAlternateData = shift;

  die 'implement interface';
}

sub getNoteApplicationData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub getNoteApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

  die 'implement interface';
}

sub setNoteApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;
  my $value = shift;

  die 'implement interface';
}

sub unsetNoteApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

  die 'implement interface';
}

sub getNoteContent{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub getNoteSearchText{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $noteOnly = shift;
  my $tokenizeForIndexing = shift;

  die 'implement interface';
}

sub getResourceSearchText{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub getNoteTagNames{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub createNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $note = shift;

  die 'implement interface';
}

sub updateNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $note = shift;

  die 'implement interface';
}

sub deleteNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub expungeNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub expungeNotes{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuids = shift;

  die 'implement interface';
}

sub expungeInactiveNotes{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub copyNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;
  my $toNotebookGuid = shift;

  die 'implement interface';
}

sub listNoteVersions{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;

  die 'implement interface';
}

sub getNoteVersion{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;
  my $updateSequenceNum = shift;
  my $withResourcesData = shift;
  my $withResourcesRecognition = shift;
  my $withResourcesAlternateData = shift;

  die 'implement interface';
}

sub getResource{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $withData = shift;
  my $withRecognition = shift;
  my $withAttributes = shift;
  my $withAlternateData = shift;

  die 'implement interface';
}

sub getResourceApplicationData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub getResourceApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

  die 'implement interface';
}

sub setResourceApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;
  my $value = shift;

  die 'implement interface';
}

sub unsetResourceApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

  die 'implement interface';
}

sub updateResource{
  my $self = shift;
  my $authenticationToken = shift;
  my $resource = shift;

  die 'implement interface';
}

sub getResourceData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub getResourceByHash{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;
  my $contentHash = shift;
  my $withData = shift;
  my $withRecognition = shift;
  my $withAlternateData = shift;

  die 'implement interface';
}

sub getResourceRecognition{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub getResourceAlternateData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub getResourceAttributes{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub getAccountSize{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub getAds{
  my $self = shift;
  my $authenticationToken = shift;
  my $adParameters = shift;

  die 'implement interface';
}

sub getRandomAd{
  my $self = shift;
  my $authenticationToken = shift;
  my $adParameters = shift;

  die 'implement interface';
}

sub getPublicNotebook{
  my $self = shift;
  my $userId = shift;
  my $publicUri = shift;

  die 'implement interface';
}

sub createSharedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $sharedNotebook = shift;

  die 'implement interface';
}

sub sendMessageToSharedNotebookMembers{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebookGuid = shift;
  my $messageText = shift;
  my $recipients = shift;

  die 'implement interface';
}

sub listSharedNotebooks{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub expungeSharedNotebooks{
  my $self = shift;
  my $authenticationToken = shift;
  my $sharedNotebookIds = shift;

  die 'implement interface';
}

sub createLinkedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;

  die 'implement interface';
}

sub updateLinkedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;

  die 'implement interface';
}

sub listLinkedNotebooks{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub expungeLinkedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub authenticateToSharedNotebook{
  my $self = shift;
  my $shareKey = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub getSharedNotebookByAuth{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub emailNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $parameters = shift;

  die 'implement interface';
}

sub shareNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub stopSharingNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  die 'implement interface';
}

sub authenticateToSharedNote{
  my $self = shift;
  my $guid = shift;
  my $noteKey = shift;

  die 'implement interface';
}

package EDAMNoteStore::NoteStoreRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub getSyncState{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->getSyncState($authenticationToken);
}

sub getSyncChunk{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $afterUSN = ($request->{'afterUSN'}) ? $request->{'afterUSN'} : undef;
  my $maxEntries = ($request->{'maxEntries'}) ? $request->{'maxEntries'} : undef;
  my $fullSyncOnly = ($request->{'fullSyncOnly'}) ? $request->{'fullSyncOnly'} : undef;
  return $self->{impl}->getSyncChunk($authenticationToken, $afterUSN, $maxEntries, $fullSyncOnly);
}

sub getFilteredSyncChunk{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $afterUSN = ($request->{'afterUSN'}) ? $request->{'afterUSN'} : undef;
  my $maxEntries = ($request->{'maxEntries'}) ? $request->{'maxEntries'} : undef;
  my $filter = ($request->{'filter'}) ? $request->{'filter'} : undef;
  return $self->{impl}->getFilteredSyncChunk($authenticationToken, $afterUSN, $maxEntries, $filter);
}

sub getLinkedNotebookSyncState{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $linkedNotebook = ($request->{'linkedNotebook'}) ? $request->{'linkedNotebook'} : undef;
  return $self->{impl}->getLinkedNotebookSyncState($authenticationToken, $linkedNotebook);
}

sub getLinkedNotebookSyncChunk{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $linkedNotebook = ($request->{'linkedNotebook'}) ? $request->{'linkedNotebook'} : undef;
  my $afterUSN = ($request->{'afterUSN'}) ? $request->{'afterUSN'} : undef;
  my $maxEntries = ($request->{'maxEntries'}) ? $request->{'maxEntries'} : undef;
  my $fullSyncOnly = ($request->{'fullSyncOnly'}) ? $request->{'fullSyncOnly'} : undef;
  return $self->{impl}->getLinkedNotebookSyncChunk($authenticationToken, $linkedNotebook, $afterUSN, $maxEntries, $fullSyncOnly);
}

sub listNotebooks{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->listNotebooks($authenticationToken);
}

sub getNotebook{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getNotebook($authenticationToken, $guid);
}

sub getDefaultNotebook{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->getDefaultNotebook($authenticationToken);
}

sub createNotebook{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $notebook = ($request->{'notebook'}) ? $request->{'notebook'} : undef;
  return $self->{impl}->createNotebook($authenticationToken, $notebook);
}

sub updateNotebook{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $notebook = ($request->{'notebook'}) ? $request->{'notebook'} : undef;
  return $self->{impl}->updateNotebook($authenticationToken, $notebook);
}

sub expungeNotebook{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->expungeNotebook($authenticationToken, $guid);
}

sub listTags{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->listTags($authenticationToken);
}

sub listTagsByNotebook{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $notebookGuid = ($request->{'notebookGuid'}) ? $request->{'notebookGuid'} : undef;
  return $self->{impl}->listTagsByNotebook($authenticationToken, $notebookGuid);
}

sub getTag{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getTag($authenticationToken, $guid);
}

sub createTag{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $tag = ($request->{'tag'}) ? $request->{'tag'} : undef;
  return $self->{impl}->createTag($authenticationToken, $tag);
}

sub updateTag{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $tag = ($request->{'tag'}) ? $request->{'tag'} : undef;
  return $self->{impl}->updateTag($authenticationToken, $tag);
}

sub untagAll{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->untagAll($authenticationToken, $guid);
}

sub expungeTag{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->expungeTag($authenticationToken, $guid);
}

sub listSearches{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->listSearches($authenticationToken);
}

sub getSearch{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getSearch($authenticationToken, $guid);
}

sub createSearch{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $search = ($request->{'search'}) ? $request->{'search'} : undef;
  return $self->{impl}->createSearch($authenticationToken, $search);
}

sub updateSearch{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $search = ($request->{'search'}) ? $request->{'search'} : undef;
  return $self->{impl}->updateSearch($authenticationToken, $search);
}

sub expungeSearch{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->expungeSearch($authenticationToken, $guid);
}

sub findNotes{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $filter = ($request->{'filter'}) ? $request->{'filter'} : undef;
  my $offset = ($request->{'offset'}) ? $request->{'offset'} : undef;
  my $maxNotes = ($request->{'maxNotes'}) ? $request->{'maxNotes'} : undef;
  return $self->{impl}->findNotes($authenticationToken, $filter, $offset, $maxNotes);
}

sub findNoteOffset{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $filter = ($request->{'filter'}) ? $request->{'filter'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->findNoteOffset($authenticationToken, $filter, $guid);
}

sub findNotesMetadata{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $filter = ($request->{'filter'}) ? $request->{'filter'} : undef;
  my $offset = ($request->{'offset'}) ? $request->{'offset'} : undef;
  my $maxNotes = ($request->{'maxNotes'}) ? $request->{'maxNotes'} : undef;
  my $resultSpec = ($request->{'resultSpec'}) ? $request->{'resultSpec'} : undef;
  return $self->{impl}->findNotesMetadata($authenticationToken, $filter, $offset, $maxNotes, $resultSpec);
}

sub findNoteCounts{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $filter = ($request->{'filter'}) ? $request->{'filter'} : undef;
  my $withTrash = ($request->{'withTrash'}) ? $request->{'withTrash'} : undef;
  return $self->{impl}->findNoteCounts($authenticationToken, $filter, $withTrash);
}

sub getNote{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  my $withContent = ($request->{'withContent'}) ? $request->{'withContent'} : undef;
  my $withResourcesData = ($request->{'withResourcesData'}) ? $request->{'withResourcesData'} : undef;
  my $withResourcesRecognition = ($request->{'withResourcesRecognition'}) ? $request->{'withResourcesRecognition'} : undef;
  my $withResourcesAlternateData = ($request->{'withResourcesAlternateData'}) ? $request->{'withResourcesAlternateData'} : undef;
  return $self->{impl}->getNote($authenticationToken, $guid, $withContent, $withResourcesData, $withResourcesRecognition, $withResourcesAlternateData);
}

sub getNoteApplicationData{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getNoteApplicationData($authenticationToken, $guid);
}

sub getNoteApplicationDataEntry{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  return $self->{impl}->getNoteApplicationDataEntry($authenticationToken, $guid, $key);
}

sub setNoteApplicationDataEntry{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->setNoteApplicationDataEntry($authenticationToken, $guid, $key, $value);
}

sub unsetNoteApplicationDataEntry{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  return $self->{impl}->unsetNoteApplicationDataEntry($authenticationToken, $guid, $key);
}

sub getNoteContent{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getNoteContent($authenticationToken, $guid);
}

sub getNoteSearchText{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  my $noteOnly = ($request->{'noteOnly'}) ? $request->{'noteOnly'} : undef;
  my $tokenizeForIndexing = ($request->{'tokenizeForIndexing'}) ? $request->{'tokenizeForIndexing'} : undef;
  return $self->{impl}->getNoteSearchText($authenticationToken, $guid, $noteOnly, $tokenizeForIndexing);
}

sub getResourceSearchText{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getResourceSearchText($authenticationToken, $guid);
}

sub getNoteTagNames{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getNoteTagNames($authenticationToken, $guid);
}

sub createNote{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $note = ($request->{'note'}) ? $request->{'note'} : undef;
  return $self->{impl}->createNote($authenticationToken, $note);
}

sub updateNote{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $note = ($request->{'note'}) ? $request->{'note'} : undef;
  return $self->{impl}->updateNote($authenticationToken, $note);
}

sub deleteNote{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->deleteNote($authenticationToken, $guid);
}

sub expungeNote{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->expungeNote($authenticationToken, $guid);
}

sub expungeNotes{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $noteGuids = ($request->{'noteGuids'}) ? $request->{'noteGuids'} : undef;
  return $self->{impl}->expungeNotes($authenticationToken, $noteGuids);
}

sub expungeInactiveNotes{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->expungeInactiveNotes($authenticationToken);
}

sub copyNote{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $noteGuid = ($request->{'noteGuid'}) ? $request->{'noteGuid'} : undef;
  my $toNotebookGuid = ($request->{'toNotebookGuid'}) ? $request->{'toNotebookGuid'} : undef;
  return $self->{impl}->copyNote($authenticationToken, $noteGuid, $toNotebookGuid);
}

sub listNoteVersions{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $noteGuid = ($request->{'noteGuid'}) ? $request->{'noteGuid'} : undef;
  return $self->{impl}->listNoteVersions($authenticationToken, $noteGuid);
}

sub getNoteVersion{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $noteGuid = ($request->{'noteGuid'}) ? $request->{'noteGuid'} : undef;
  my $updateSequenceNum = ($request->{'updateSequenceNum'}) ? $request->{'updateSequenceNum'} : undef;
  my $withResourcesData = ($request->{'withResourcesData'}) ? $request->{'withResourcesData'} : undef;
  my $withResourcesRecognition = ($request->{'withResourcesRecognition'}) ? $request->{'withResourcesRecognition'} : undef;
  my $withResourcesAlternateData = ($request->{'withResourcesAlternateData'}) ? $request->{'withResourcesAlternateData'} : undef;
  return $self->{impl}->getNoteVersion($authenticationToken, $noteGuid, $updateSequenceNum, $withResourcesData, $withResourcesRecognition, $withResourcesAlternateData);
}

sub getResource{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  my $withData = ($request->{'withData'}) ? $request->{'withData'} : undef;
  my $withRecognition = ($request->{'withRecognition'}) ? $request->{'withRecognition'} : undef;
  my $withAttributes = ($request->{'withAttributes'}) ? $request->{'withAttributes'} : undef;
  my $withAlternateData = ($request->{'withAlternateData'}) ? $request->{'withAlternateData'} : undef;
  return $self->{impl}->getResource($authenticationToken, $guid, $withData, $withRecognition, $withAttributes, $withAlternateData);
}

sub getResourceApplicationData{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getResourceApplicationData($authenticationToken, $guid);
}

sub getResourceApplicationDataEntry{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  return $self->{impl}->getResourceApplicationDataEntry($authenticationToken, $guid, $key);
}

sub setResourceApplicationDataEntry{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->setResourceApplicationDataEntry($authenticationToken, $guid, $key, $value);
}

sub unsetResourceApplicationDataEntry{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  return $self->{impl}->unsetResourceApplicationDataEntry($authenticationToken, $guid, $key);
}

sub updateResource{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $resource = ($request->{'resource'}) ? $request->{'resource'} : undef;
  return $self->{impl}->updateResource($authenticationToken, $resource);
}

sub getResourceData{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getResourceData($authenticationToken, $guid);
}

sub getResourceByHash{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $noteGuid = ($request->{'noteGuid'}) ? $request->{'noteGuid'} : undef;
  my $contentHash = ($request->{'contentHash'}) ? $request->{'contentHash'} : undef;
  my $withData = ($request->{'withData'}) ? $request->{'withData'} : undef;
  my $withRecognition = ($request->{'withRecognition'}) ? $request->{'withRecognition'} : undef;
  my $withAlternateData = ($request->{'withAlternateData'}) ? $request->{'withAlternateData'} : undef;
  return $self->{impl}->getResourceByHash($authenticationToken, $noteGuid, $contentHash, $withData, $withRecognition, $withAlternateData);
}

sub getResourceRecognition{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getResourceRecognition($authenticationToken, $guid);
}

sub getResourceAlternateData{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getResourceAlternateData($authenticationToken, $guid);
}

sub getResourceAttributes{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->getResourceAttributes($authenticationToken, $guid);
}

sub getAccountSize{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->getAccountSize($authenticationToken);
}

sub getAds{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $adParameters = ($request->{'adParameters'}) ? $request->{'adParameters'} : undef;
  return $self->{impl}->getAds($authenticationToken, $adParameters);
}

sub getRandomAd{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $adParameters = ($request->{'adParameters'}) ? $request->{'adParameters'} : undef;
  return $self->{impl}->getRandomAd($authenticationToken, $adParameters);
}

sub getPublicNotebook{
  my ($self, $request) = @_;

  my $userId = ($request->{'userId'}) ? $request->{'userId'} : undef;
  my $publicUri = ($request->{'publicUri'}) ? $request->{'publicUri'} : undef;
  return $self->{impl}->getPublicNotebook($userId, $publicUri);
}

sub createSharedNotebook{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $sharedNotebook = ($request->{'sharedNotebook'}) ? $request->{'sharedNotebook'} : undef;
  return $self->{impl}->createSharedNotebook($authenticationToken, $sharedNotebook);
}

sub sendMessageToSharedNotebookMembers{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $notebookGuid = ($request->{'notebookGuid'}) ? $request->{'notebookGuid'} : undef;
  my $messageText = ($request->{'messageText'}) ? $request->{'messageText'} : undef;
  my $recipients = ($request->{'recipients'}) ? $request->{'recipients'} : undef;
  return $self->{impl}->sendMessageToSharedNotebookMembers($authenticationToken, $notebookGuid, $messageText, $recipients);
}

sub listSharedNotebooks{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->listSharedNotebooks($authenticationToken);
}

sub expungeSharedNotebooks{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $sharedNotebookIds = ($request->{'sharedNotebookIds'}) ? $request->{'sharedNotebookIds'} : undef;
  return $self->{impl}->expungeSharedNotebooks($authenticationToken, $sharedNotebookIds);
}

sub createLinkedNotebook{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $linkedNotebook = ($request->{'linkedNotebook'}) ? $request->{'linkedNotebook'} : undef;
  return $self->{impl}->createLinkedNotebook($authenticationToken, $linkedNotebook);
}

sub updateLinkedNotebook{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $linkedNotebook = ($request->{'linkedNotebook'}) ? $request->{'linkedNotebook'} : undef;
  return $self->{impl}->updateLinkedNotebook($authenticationToken, $linkedNotebook);
}

sub listLinkedNotebooks{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->listLinkedNotebooks($authenticationToken);
}

sub expungeLinkedNotebook{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->expungeLinkedNotebook($authenticationToken, $guid);
}

sub authenticateToSharedNotebook{
  my ($self, $request) = @_;

  my $shareKey = ($request->{'shareKey'}) ? $request->{'shareKey'} : undef;
  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->authenticateToSharedNotebook($shareKey, $authenticationToken);
}

sub getSharedNotebookByAuth{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->getSharedNotebookByAuth($authenticationToken);
}

sub emailNote{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $parameters = ($request->{'parameters'}) ? $request->{'parameters'} : undef;
  return $self->{impl}->emailNote($authenticationToken, $parameters);
}

sub shareNote{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->shareNote($authenticationToken, $guid);
}

sub stopSharingNote{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  return $self->{impl}->stopSharingNote($authenticationToken, $guid);
}

sub authenticateToSharedNote{
  my ($self, $request) = @_;

  my $guid = ($request->{'guid'}) ? $request->{'guid'} : undef;
  my $noteKey = ($request->{'noteKey'}) ? $request->{'noteKey'} : undef;
  return $self->{impl}->authenticateToSharedNote($guid, $noteKey);
}

package EDAMNoteStore::NoteStoreClient;


use base qw(EDAMNoteStore::NoteStoreIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub getSyncState{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_getSyncState($authenticationToken);
  return $self->recv_getSyncState();
}

sub send_getSyncState{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('getSyncState', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getSyncState_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getSyncState{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getSyncState_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "getSyncState failed: unknown result";
}
sub getSyncChunk{
  my $self = shift;
  my $authenticationToken = shift;
  my $afterUSN = shift;
  my $maxEntries = shift;
  my $fullSyncOnly = shift;

    $self->send_getSyncChunk($authenticationToken, $afterUSN, $maxEntries, $fullSyncOnly);
  return $self->recv_getSyncChunk();
}

sub send_getSyncChunk{
  my $self = shift;
  my $authenticationToken = shift;
  my $afterUSN = shift;
  my $maxEntries = shift;
  my $fullSyncOnly = shift;

  $self->{output}->writeMessageBegin('getSyncChunk', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getSyncChunk_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{afterUSN} = $afterUSN;
  $args->{maxEntries} = $maxEntries;
  $args->{fullSyncOnly} = $fullSyncOnly;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getSyncChunk{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getSyncChunk_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "getSyncChunk failed: unknown result";
}
sub getFilteredSyncChunk{
  my $self = shift;
  my $authenticationToken = shift;
  my $afterUSN = shift;
  my $maxEntries = shift;
  my $filter = shift;

    $self->send_getFilteredSyncChunk($authenticationToken, $afterUSN, $maxEntries, $filter);
  return $self->recv_getFilteredSyncChunk();
}

sub send_getFilteredSyncChunk{
  my $self = shift;
  my $authenticationToken = shift;
  my $afterUSN = shift;
  my $maxEntries = shift;
  my $filter = shift;

  $self->{output}->writeMessageBegin('getFilteredSyncChunk', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getFilteredSyncChunk_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{afterUSN} = $afterUSN;
  $args->{maxEntries} = $maxEntries;
  $args->{filter} = $filter;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getFilteredSyncChunk{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getFilteredSyncChunk_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "getFilteredSyncChunk failed: unknown result";
}
sub getLinkedNotebookSyncState{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;

    $self->send_getLinkedNotebookSyncState($authenticationToken, $linkedNotebook);
  return $self->recv_getLinkedNotebookSyncState();
}

sub send_getLinkedNotebookSyncState{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;

  $self->{output}->writeMessageBegin('getLinkedNotebookSyncState', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getLinkedNotebookSyncState_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{linkedNotebook} = $linkedNotebook;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getLinkedNotebookSyncState{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getLinkedNotebookSyncState_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getLinkedNotebookSyncState failed: unknown result";
}
sub getLinkedNotebookSyncChunk{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;
  my $afterUSN = shift;
  my $maxEntries = shift;
  my $fullSyncOnly = shift;

    $self->send_getLinkedNotebookSyncChunk($authenticationToken, $linkedNotebook, $afterUSN, $maxEntries, $fullSyncOnly);
  return $self->recv_getLinkedNotebookSyncChunk();
}

sub send_getLinkedNotebookSyncChunk{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;
  my $afterUSN = shift;
  my $maxEntries = shift;
  my $fullSyncOnly = shift;

  $self->{output}->writeMessageBegin('getLinkedNotebookSyncChunk', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getLinkedNotebookSyncChunk_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{linkedNotebook} = $linkedNotebook;
  $args->{afterUSN} = $afterUSN;
  $args->{maxEntries} = $maxEntries;
  $args->{fullSyncOnly} = $fullSyncOnly;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getLinkedNotebookSyncChunk{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getLinkedNotebookSyncChunk_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getLinkedNotebookSyncChunk failed: unknown result";
}
sub listNotebooks{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_listNotebooks($authenticationToken);
  return $self->recv_listNotebooks();
}

sub send_listNotebooks{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('listNotebooks', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_listNotebooks_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_listNotebooks{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_listNotebooks_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "listNotebooks failed: unknown result";
}
sub getNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getNotebook($authenticationToken, $guid);
  return $self->recv_getNotebook();
}

sub send_getNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getNotebook_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getNotebook failed: unknown result";
}
sub getDefaultNotebook{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_getDefaultNotebook($authenticationToken);
  return $self->recv_getDefaultNotebook();
}

sub send_getDefaultNotebook{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('getDefaultNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getDefaultNotebook_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getDefaultNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getDefaultNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "getDefaultNotebook failed: unknown result";
}
sub createNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebook = shift;

    $self->send_createNotebook($authenticationToken, $notebook);
  return $self->recv_createNotebook();
}

sub send_createNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebook = shift;

  $self->{output}->writeMessageBegin('createNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_createNotebook_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{notebook} = $notebook;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_createNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "createNotebook failed: unknown result";
}
sub updateNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebook = shift;

    $self->send_updateNotebook($authenticationToken, $notebook);
  return $self->recv_updateNotebook();
}

sub send_updateNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebook = shift;

  $self->{output}->writeMessageBegin('updateNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_updateNotebook_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{notebook} = $notebook;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_updateNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_updateNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "updateNotebook failed: unknown result";
}
sub expungeNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_expungeNotebook($authenticationToken, $guid);
  return $self->recv_expungeNotebook();
}

sub send_expungeNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('expungeNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_expungeNotebook_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_expungeNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_expungeNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "expungeNotebook failed: unknown result";
}
sub listTags{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_listTags($authenticationToken);
  return $self->recv_listTags();
}

sub send_listTags{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('listTags', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_listTags_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_listTags{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_listTags_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "listTags failed: unknown result";
}
sub listTagsByNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebookGuid = shift;

    $self->send_listTagsByNotebook($authenticationToken, $notebookGuid);
  return $self->recv_listTagsByNotebook();
}

sub send_listTagsByNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebookGuid = shift;

  $self->{output}->writeMessageBegin('listTagsByNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_listTagsByNotebook_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{notebookGuid} = $notebookGuid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_listTagsByNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_listTagsByNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "listTagsByNotebook failed: unknown result";
}
sub getTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getTag($authenticationToken, $guid);
  return $self->recv_getTag();
}

sub send_getTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getTag', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getTag_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getTag{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getTag_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getTag failed: unknown result";
}
sub createTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $tag = shift;

    $self->send_createTag($authenticationToken, $tag);
  return $self->recv_createTag();
}

sub send_createTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $tag = shift;

  $self->{output}->writeMessageBegin('createTag', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_createTag_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{tag} = $tag;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createTag{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_createTag_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "createTag failed: unknown result";
}
sub updateTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $tag = shift;

    $self->send_updateTag($authenticationToken, $tag);
  return $self->recv_updateTag();
}

sub send_updateTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $tag = shift;

  $self->{output}->writeMessageBegin('updateTag', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_updateTag_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{tag} = $tag;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_updateTag{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_updateTag_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "updateTag failed: unknown result";
}
sub untagAll{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_untagAll($authenticationToken, $guid);
  $self->recv_untagAll();
}

sub send_untagAll{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('untagAll', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_untagAll_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_untagAll{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_untagAll_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  return;
}
sub expungeTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_expungeTag($authenticationToken, $guid);
  return $self->recv_expungeTag();
}

sub send_expungeTag{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('expungeTag', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_expungeTag_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_expungeTag{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_expungeTag_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "expungeTag failed: unknown result";
}
sub listSearches{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_listSearches($authenticationToken);
  return $self->recv_listSearches();
}

sub send_listSearches{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('listSearches', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_listSearches_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_listSearches{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_listSearches_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "listSearches failed: unknown result";
}
sub getSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getSearch($authenticationToken, $guid);
  return $self->recv_getSearch();
}

sub send_getSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getSearch', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getSearch_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getSearch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getSearch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getSearch failed: unknown result";
}
sub createSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $search = shift;

    $self->send_createSearch($authenticationToken, $search);
  return $self->recv_createSearch();
}

sub send_createSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $search = shift;

  $self->{output}->writeMessageBegin('createSearch', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_createSearch_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{search} = $search;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createSearch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_createSearch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "createSearch failed: unknown result";
}
sub updateSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $search = shift;

    $self->send_updateSearch($authenticationToken, $search);
  return $self->recv_updateSearch();
}

sub send_updateSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $search = shift;

  $self->{output}->writeMessageBegin('updateSearch', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_updateSearch_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{search} = $search;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_updateSearch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_updateSearch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "updateSearch failed: unknown result";
}
sub expungeSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_expungeSearch($authenticationToken, $guid);
  return $self->recv_expungeSearch();
}

sub send_expungeSearch{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('expungeSearch', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_expungeSearch_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_expungeSearch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_expungeSearch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "expungeSearch failed: unknown result";
}
sub findNotes{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $offset = shift;
  my $maxNotes = shift;

    $self->send_findNotes($authenticationToken, $filter, $offset, $maxNotes);
  return $self->recv_findNotes();
}

sub send_findNotes{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $offset = shift;
  my $maxNotes = shift;

  $self->{output}->writeMessageBegin('findNotes', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_findNotes_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{filter} = $filter;
  $args->{offset} = $offset;
  $args->{maxNotes} = $maxNotes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_findNotes{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_findNotes_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "findNotes failed: unknown result";
}
sub findNoteOffset{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $guid = shift;

    $self->send_findNoteOffset($authenticationToken, $filter, $guid);
  return $self->recv_findNoteOffset();
}

sub send_findNoteOffset{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('findNoteOffset', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_findNoteOffset_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{filter} = $filter;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_findNoteOffset{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_findNoteOffset_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "findNoteOffset failed: unknown result";
}
sub findNotesMetadata{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $offset = shift;
  my $maxNotes = shift;
  my $resultSpec = shift;

    $self->send_findNotesMetadata($authenticationToken, $filter, $offset, $maxNotes, $resultSpec);
  return $self->recv_findNotesMetadata();
}

sub send_findNotesMetadata{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $offset = shift;
  my $maxNotes = shift;
  my $resultSpec = shift;

  $self->{output}->writeMessageBegin('findNotesMetadata', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_findNotesMetadata_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{filter} = $filter;
  $args->{offset} = $offset;
  $args->{maxNotes} = $maxNotes;
  $args->{resultSpec} = $resultSpec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_findNotesMetadata{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_findNotesMetadata_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "findNotesMetadata failed: unknown result";
}
sub findNoteCounts{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $withTrash = shift;

    $self->send_findNoteCounts($authenticationToken, $filter, $withTrash);
  return $self->recv_findNoteCounts();
}

sub send_findNoteCounts{
  my $self = shift;
  my $authenticationToken = shift;
  my $filter = shift;
  my $withTrash = shift;

  $self->{output}->writeMessageBegin('findNoteCounts', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_findNoteCounts_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{filter} = $filter;
  $args->{withTrash} = $withTrash;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_findNoteCounts{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_findNoteCounts_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "findNoteCounts failed: unknown result";
}
sub getNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $withContent = shift;
  my $withResourcesData = shift;
  my $withResourcesRecognition = shift;
  my $withResourcesAlternateData = shift;

    $self->send_getNote($authenticationToken, $guid, $withContent, $withResourcesData, $withResourcesRecognition, $withResourcesAlternateData);
  return $self->recv_getNote();
}

sub send_getNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $withContent = shift;
  my $withResourcesData = shift;
  my $withResourcesRecognition = shift;
  my $withResourcesAlternateData = shift;

  $self->{output}->writeMessageBegin('getNote', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getNote_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->{withContent} = $withContent;
  $args->{withResourcesData} = $withResourcesData;
  $args->{withResourcesRecognition} = $withResourcesRecognition;
  $args->{withResourcesAlternateData} = $withResourcesAlternateData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getNote{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getNote_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getNote failed: unknown result";
}
sub getNoteApplicationData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getNoteApplicationData($authenticationToken, $guid);
  return $self->recv_getNoteApplicationData();
}

sub send_getNoteApplicationData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getNoteApplicationData', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getNoteApplicationData_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getNoteApplicationData{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getNoteApplicationData_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getNoteApplicationData failed: unknown result";
}
sub getNoteApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

    $self->send_getNoteApplicationDataEntry($authenticationToken, $guid, $key);
  return $self->recv_getNoteApplicationDataEntry();
}

sub send_getNoteApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

  $self->{output}->writeMessageBegin('getNoteApplicationDataEntry', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getNoteApplicationDataEntry_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->{key} = $key;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getNoteApplicationDataEntry{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getNoteApplicationDataEntry_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getNoteApplicationDataEntry failed: unknown result";
}
sub setNoteApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;
  my $value = shift;

    $self->send_setNoteApplicationDataEntry($authenticationToken, $guid, $key, $value);
  return $self->recv_setNoteApplicationDataEntry();
}

sub send_setNoteApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('setNoteApplicationDataEntry', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_setNoteApplicationDataEntry_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->{key} = $key;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_setNoteApplicationDataEntry{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_setNoteApplicationDataEntry_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "setNoteApplicationDataEntry failed: unknown result";
}
sub unsetNoteApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

    $self->send_unsetNoteApplicationDataEntry($authenticationToken, $guid, $key);
  return $self->recv_unsetNoteApplicationDataEntry();
}

sub send_unsetNoteApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

  $self->{output}->writeMessageBegin('unsetNoteApplicationDataEntry', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_unsetNoteApplicationDataEntry_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->{key} = $key;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_unsetNoteApplicationDataEntry{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_unsetNoteApplicationDataEntry_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "unsetNoteApplicationDataEntry failed: unknown result";
}
sub getNoteContent{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getNoteContent($authenticationToken, $guid);
  return $self->recv_getNoteContent();
}

sub send_getNoteContent{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getNoteContent', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getNoteContent_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getNoteContent{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getNoteContent_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getNoteContent failed: unknown result";
}
sub getNoteSearchText{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $noteOnly = shift;
  my $tokenizeForIndexing = shift;

    $self->send_getNoteSearchText($authenticationToken, $guid, $noteOnly, $tokenizeForIndexing);
  return $self->recv_getNoteSearchText();
}

sub send_getNoteSearchText{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $noteOnly = shift;
  my $tokenizeForIndexing = shift;

  $self->{output}->writeMessageBegin('getNoteSearchText', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getNoteSearchText_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->{noteOnly} = $noteOnly;
  $args->{tokenizeForIndexing} = $tokenizeForIndexing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getNoteSearchText{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getNoteSearchText_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getNoteSearchText failed: unknown result";
}
sub getResourceSearchText{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getResourceSearchText($authenticationToken, $guid);
  return $self->recv_getResourceSearchText();
}

sub send_getResourceSearchText{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getResourceSearchText', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getResourceSearchText_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getResourceSearchText{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getResourceSearchText_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getResourceSearchText failed: unknown result";
}
sub getNoteTagNames{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getNoteTagNames($authenticationToken, $guid);
  return $self->recv_getNoteTagNames();
}

sub send_getNoteTagNames{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getNoteTagNames', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getNoteTagNames_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getNoteTagNames{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getNoteTagNames_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getNoteTagNames failed: unknown result";
}
sub createNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $note = shift;

    $self->send_createNote($authenticationToken, $note);
  return $self->recv_createNote();
}

sub send_createNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $note = shift;

  $self->{output}->writeMessageBegin('createNote', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_createNote_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{note} = $note;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createNote{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_createNote_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "createNote failed: unknown result";
}
sub updateNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $note = shift;

    $self->send_updateNote($authenticationToken, $note);
  return $self->recv_updateNote();
}

sub send_updateNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $note = shift;

  $self->{output}->writeMessageBegin('updateNote', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_updateNote_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{note} = $note;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_updateNote{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_updateNote_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "updateNote failed: unknown result";
}
sub deleteNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_deleteNote($authenticationToken, $guid);
  return $self->recv_deleteNote();
}

sub send_deleteNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('deleteNote', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_deleteNote_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteNote{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_deleteNote_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "deleteNote failed: unknown result";
}
sub expungeNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_expungeNote($authenticationToken, $guid);
  return $self->recv_expungeNote();
}

sub send_expungeNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('expungeNote', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_expungeNote_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_expungeNote{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_expungeNote_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "expungeNote failed: unknown result";
}
sub expungeNotes{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuids = shift;

    $self->send_expungeNotes($authenticationToken, $noteGuids);
  return $self->recv_expungeNotes();
}

sub send_expungeNotes{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuids = shift;

  $self->{output}->writeMessageBegin('expungeNotes', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_expungeNotes_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{noteGuids} = $noteGuids;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_expungeNotes{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_expungeNotes_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "expungeNotes failed: unknown result";
}
sub expungeInactiveNotes{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_expungeInactiveNotes($authenticationToken);
  return $self->recv_expungeInactiveNotes();
}

sub send_expungeInactiveNotes{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('expungeInactiveNotes', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_expungeInactiveNotes_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_expungeInactiveNotes{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_expungeInactiveNotes_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "expungeInactiveNotes failed: unknown result";
}
sub copyNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;
  my $toNotebookGuid = shift;

    $self->send_copyNote($authenticationToken, $noteGuid, $toNotebookGuid);
  return $self->recv_copyNote();
}

sub send_copyNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;
  my $toNotebookGuid = shift;

  $self->{output}->writeMessageBegin('copyNote', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_copyNote_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{noteGuid} = $noteGuid;
  $args->{toNotebookGuid} = $toNotebookGuid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_copyNote{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_copyNote_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "copyNote failed: unknown result";
}
sub listNoteVersions{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;

    $self->send_listNoteVersions($authenticationToken, $noteGuid);
  return $self->recv_listNoteVersions();
}

sub send_listNoteVersions{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;

  $self->{output}->writeMessageBegin('listNoteVersions', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_listNoteVersions_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{noteGuid} = $noteGuid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_listNoteVersions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_listNoteVersions_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "listNoteVersions failed: unknown result";
}
sub getNoteVersion{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;
  my $updateSequenceNum = shift;
  my $withResourcesData = shift;
  my $withResourcesRecognition = shift;
  my $withResourcesAlternateData = shift;

    $self->send_getNoteVersion($authenticationToken, $noteGuid, $updateSequenceNum, $withResourcesData, $withResourcesRecognition, $withResourcesAlternateData);
  return $self->recv_getNoteVersion();
}

sub send_getNoteVersion{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;
  my $updateSequenceNum = shift;
  my $withResourcesData = shift;
  my $withResourcesRecognition = shift;
  my $withResourcesAlternateData = shift;

  $self->{output}->writeMessageBegin('getNoteVersion', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getNoteVersion_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{noteGuid} = $noteGuid;
  $args->{updateSequenceNum} = $updateSequenceNum;
  $args->{withResourcesData} = $withResourcesData;
  $args->{withResourcesRecognition} = $withResourcesRecognition;
  $args->{withResourcesAlternateData} = $withResourcesAlternateData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getNoteVersion{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getNoteVersion_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getNoteVersion failed: unknown result";
}
sub getResource{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $withData = shift;
  my $withRecognition = shift;
  my $withAttributes = shift;
  my $withAlternateData = shift;

    $self->send_getResource($authenticationToken, $guid, $withData, $withRecognition, $withAttributes, $withAlternateData);
  return $self->recv_getResource();
}

sub send_getResource{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $withData = shift;
  my $withRecognition = shift;
  my $withAttributes = shift;
  my $withAlternateData = shift;

  $self->{output}->writeMessageBegin('getResource', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getResource_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->{withData} = $withData;
  $args->{withRecognition} = $withRecognition;
  $args->{withAttributes} = $withAttributes;
  $args->{withAlternateData} = $withAlternateData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getResource{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getResource_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getResource failed: unknown result";
}
sub getResourceApplicationData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getResourceApplicationData($authenticationToken, $guid);
  return $self->recv_getResourceApplicationData();
}

sub send_getResourceApplicationData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getResourceApplicationData', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getResourceApplicationData_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getResourceApplicationData{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getResourceApplicationData_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getResourceApplicationData failed: unknown result";
}
sub getResourceApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

    $self->send_getResourceApplicationDataEntry($authenticationToken, $guid, $key);
  return $self->recv_getResourceApplicationDataEntry();
}

sub send_getResourceApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

  $self->{output}->writeMessageBegin('getResourceApplicationDataEntry', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getResourceApplicationDataEntry_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->{key} = $key;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getResourceApplicationDataEntry{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getResourceApplicationDataEntry_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getResourceApplicationDataEntry failed: unknown result";
}
sub setResourceApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;
  my $value = shift;

    $self->send_setResourceApplicationDataEntry($authenticationToken, $guid, $key, $value);
  return $self->recv_setResourceApplicationDataEntry();
}

sub send_setResourceApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('setResourceApplicationDataEntry', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_setResourceApplicationDataEntry_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->{key} = $key;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_setResourceApplicationDataEntry{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_setResourceApplicationDataEntry_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "setResourceApplicationDataEntry failed: unknown result";
}
sub unsetResourceApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

    $self->send_unsetResourceApplicationDataEntry($authenticationToken, $guid, $key);
  return $self->recv_unsetResourceApplicationDataEntry();
}

sub send_unsetResourceApplicationDataEntry{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;
  my $key = shift;

  $self->{output}->writeMessageBegin('unsetResourceApplicationDataEntry', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_unsetResourceApplicationDataEntry_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->{key} = $key;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_unsetResourceApplicationDataEntry{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_unsetResourceApplicationDataEntry_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "unsetResourceApplicationDataEntry failed: unknown result";
}
sub updateResource{
  my $self = shift;
  my $authenticationToken = shift;
  my $resource = shift;

    $self->send_updateResource($authenticationToken, $resource);
  return $self->recv_updateResource();
}

sub send_updateResource{
  my $self = shift;
  my $authenticationToken = shift;
  my $resource = shift;

  $self->{output}->writeMessageBegin('updateResource', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_updateResource_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{resource} = $resource;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_updateResource{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_updateResource_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "updateResource failed: unknown result";
}
sub getResourceData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getResourceData($authenticationToken, $guid);
  return $self->recv_getResourceData();
}

sub send_getResourceData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getResourceData', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getResourceData_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getResourceData{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getResourceData_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getResourceData failed: unknown result";
}
sub getResourceByHash{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;
  my $contentHash = shift;
  my $withData = shift;
  my $withRecognition = shift;
  my $withAlternateData = shift;

    $self->send_getResourceByHash($authenticationToken, $noteGuid, $contentHash, $withData, $withRecognition, $withAlternateData);
  return $self->recv_getResourceByHash();
}

sub send_getResourceByHash{
  my $self = shift;
  my $authenticationToken = shift;
  my $noteGuid = shift;
  my $contentHash = shift;
  my $withData = shift;
  my $withRecognition = shift;
  my $withAlternateData = shift;

  $self->{output}->writeMessageBegin('getResourceByHash', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getResourceByHash_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{noteGuid} = $noteGuid;
  $args->{contentHash} = $contentHash;
  $args->{withData} = $withData;
  $args->{withRecognition} = $withRecognition;
  $args->{withAlternateData} = $withAlternateData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getResourceByHash{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getResourceByHash_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getResourceByHash failed: unknown result";
}
sub getResourceRecognition{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getResourceRecognition($authenticationToken, $guid);
  return $self->recv_getResourceRecognition();
}

sub send_getResourceRecognition{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getResourceRecognition', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getResourceRecognition_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getResourceRecognition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getResourceRecognition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getResourceRecognition failed: unknown result";
}
sub getResourceAlternateData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getResourceAlternateData($authenticationToken, $guid);
  return $self->recv_getResourceAlternateData();
}

sub send_getResourceAlternateData{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getResourceAlternateData', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getResourceAlternateData_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getResourceAlternateData{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getResourceAlternateData_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getResourceAlternateData failed: unknown result";
}
sub getResourceAttributes{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_getResourceAttributes($authenticationToken, $guid);
  return $self->recv_getResourceAttributes();
}

sub send_getResourceAttributes{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('getResourceAttributes', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getResourceAttributes_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getResourceAttributes{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getResourceAttributes_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getResourceAttributes failed: unknown result";
}
sub getAccountSize{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_getAccountSize($authenticationToken);
  return $self->recv_getAccountSize();
}

sub send_getAccountSize{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('getAccountSize', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getAccountSize_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getAccountSize{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getAccountSize_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "getAccountSize failed: unknown result";
}
sub getAds{
  my $self = shift;
  my $authenticationToken = shift;
  my $adParameters = shift;

    $self->send_getAds($authenticationToken, $adParameters);
  return $self->recv_getAds();
}

sub send_getAds{
  my $self = shift;
  my $authenticationToken = shift;
  my $adParameters = shift;

  $self->{output}->writeMessageBegin('getAds', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getAds_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{adParameters} = $adParameters;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getAds{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getAds_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "getAds failed: unknown result";
}
sub getRandomAd{
  my $self = shift;
  my $authenticationToken = shift;
  my $adParameters = shift;

    $self->send_getRandomAd($authenticationToken, $adParameters);
  return $self->recv_getRandomAd();
}

sub send_getRandomAd{
  my $self = shift;
  my $authenticationToken = shift;
  my $adParameters = shift;

  $self->{output}->writeMessageBegin('getRandomAd', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getRandomAd_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{adParameters} = $adParameters;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRandomAd{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getRandomAd_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "getRandomAd failed: unknown result";
}
sub getPublicNotebook{
  my $self = shift;
  my $userId = shift;
  my $publicUri = shift;

    $self->send_getPublicNotebook($userId, $publicUri);
  return $self->recv_getPublicNotebook();
}

sub send_getPublicNotebook{
  my $self = shift;
  my $userId = shift;
  my $publicUri = shift;

  $self->{output}->writeMessageBegin('getPublicNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getPublicNotebook_args();
  $args->{userId} = $userId;
  $args->{publicUri} = $publicUri;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getPublicNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getPublicNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  die "getPublicNotebook failed: unknown result";
}
sub createSharedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $sharedNotebook = shift;

    $self->send_createSharedNotebook($authenticationToken, $sharedNotebook);
  return $self->recv_createSharedNotebook();
}

sub send_createSharedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $sharedNotebook = shift;

  $self->{output}->writeMessageBegin('createSharedNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_createSharedNotebook_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{sharedNotebook} = $sharedNotebook;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createSharedNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_createSharedNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "createSharedNotebook failed: unknown result";
}
sub sendMessageToSharedNotebookMembers{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebookGuid = shift;
  my $messageText = shift;
  my $recipients = shift;

    $self->send_sendMessageToSharedNotebookMembers($authenticationToken, $notebookGuid, $messageText, $recipients);
  return $self->recv_sendMessageToSharedNotebookMembers();
}

sub send_sendMessageToSharedNotebookMembers{
  my $self = shift;
  my $authenticationToken = shift;
  my $notebookGuid = shift;
  my $messageText = shift;
  my $recipients = shift;

  $self->{output}->writeMessageBegin('sendMessageToSharedNotebookMembers', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_sendMessageToSharedNotebookMembers_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{notebookGuid} = $notebookGuid;
  $args->{messageText} = $messageText;
  $args->{recipients} = $recipients;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_sendMessageToSharedNotebookMembers{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_sendMessageToSharedNotebookMembers_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "sendMessageToSharedNotebookMembers failed: unknown result";
}
sub listSharedNotebooks{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_listSharedNotebooks($authenticationToken);
  return $self->recv_listSharedNotebooks();
}

sub send_listSharedNotebooks{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('listSharedNotebooks', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_listSharedNotebooks_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_listSharedNotebooks{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_listSharedNotebooks_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "listSharedNotebooks failed: unknown result";
}
sub expungeSharedNotebooks{
  my $self = shift;
  my $authenticationToken = shift;
  my $sharedNotebookIds = shift;

    $self->send_expungeSharedNotebooks($authenticationToken, $sharedNotebookIds);
  return $self->recv_expungeSharedNotebooks();
}

sub send_expungeSharedNotebooks{
  my $self = shift;
  my $authenticationToken = shift;
  my $sharedNotebookIds = shift;

  $self->{output}->writeMessageBegin('expungeSharedNotebooks', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_expungeSharedNotebooks_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{sharedNotebookIds} = $sharedNotebookIds;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_expungeSharedNotebooks{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_expungeSharedNotebooks_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "expungeSharedNotebooks failed: unknown result";
}
sub createLinkedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;

    $self->send_createLinkedNotebook($authenticationToken, $linkedNotebook);
  return $self->recv_createLinkedNotebook();
}

sub send_createLinkedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;

  $self->{output}->writeMessageBegin('createLinkedNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_createLinkedNotebook_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{linkedNotebook} = $linkedNotebook;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createLinkedNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_createLinkedNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "createLinkedNotebook failed: unknown result";
}
sub updateLinkedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;

    $self->send_updateLinkedNotebook($authenticationToken, $linkedNotebook);
  return $self->recv_updateLinkedNotebook();
}

sub send_updateLinkedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $linkedNotebook = shift;

  $self->{output}->writeMessageBegin('updateLinkedNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_updateLinkedNotebook_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{linkedNotebook} = $linkedNotebook;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_updateLinkedNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_updateLinkedNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "updateLinkedNotebook failed: unknown result";
}
sub listLinkedNotebooks{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_listLinkedNotebooks($authenticationToken);
  return $self->recv_listLinkedNotebooks();
}

sub send_listLinkedNotebooks{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('listLinkedNotebooks', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_listLinkedNotebooks_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_listLinkedNotebooks{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_listLinkedNotebooks_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "listLinkedNotebooks failed: unknown result";
}
sub expungeLinkedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_expungeLinkedNotebook($authenticationToken, $guid);
  return $self->recv_expungeLinkedNotebook();
}

sub send_expungeLinkedNotebook{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('expungeLinkedNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_expungeLinkedNotebook_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_expungeLinkedNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_expungeLinkedNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "expungeLinkedNotebook failed: unknown result";
}
sub authenticateToSharedNotebook{
  my $self = shift;
  my $shareKey = shift;
  my $authenticationToken = shift;

    $self->send_authenticateToSharedNotebook($shareKey, $authenticationToken);
  return $self->recv_authenticateToSharedNotebook();
}

sub send_authenticateToSharedNotebook{
  my $self = shift;
  my $shareKey = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('authenticateToSharedNotebook', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_authenticateToSharedNotebook_args();
  $args->{shareKey} = $shareKey;
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_authenticateToSharedNotebook{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_authenticateToSharedNotebook_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "authenticateToSharedNotebook failed: unknown result";
}
sub getSharedNotebookByAuth{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_getSharedNotebookByAuth($authenticationToken);
  return $self->recv_getSharedNotebookByAuth();
}

sub send_getSharedNotebookByAuth{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('getSharedNotebookByAuth', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_getSharedNotebookByAuth_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getSharedNotebookByAuth{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_getSharedNotebookByAuth_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "getSharedNotebookByAuth failed: unknown result";
}
sub emailNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $parameters = shift;

    $self->send_emailNote($authenticationToken, $parameters);
  $self->recv_emailNote();
}

sub send_emailNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $parameters = shift;

  $self->{output}->writeMessageBegin('emailNote', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_emailNote_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{parameters} = $parameters;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_emailNote{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_emailNote_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  return;
}
sub shareNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_shareNote($authenticationToken, $guid);
  return $self->recv_shareNote();
}

sub send_shareNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('shareNote', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_shareNote_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shareNote{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_shareNote_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "shareNote failed: unknown result";
}
sub stopSharingNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

    $self->send_stopSharingNote($authenticationToken, $guid);
  $self->recv_stopSharingNote();
}

sub send_stopSharingNote{
  my $self = shift;
  my $authenticationToken = shift;
  my $guid = shift;

  $self->{output}->writeMessageBegin('stopSharingNote', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_stopSharingNote_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{guid} = $guid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_stopSharingNote{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_stopSharingNote_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  return;
}
sub authenticateToSharedNote{
  my $self = shift;
  my $guid = shift;
  my $noteKey = shift;

    $self->send_authenticateToSharedNote($guid, $noteKey);
  return $self->recv_authenticateToSharedNote();
}

sub send_authenticateToSharedNote{
  my $self = shift;
  my $guid = shift;
  my $noteKey = shift;

  $self->{output}->writeMessageBegin('authenticateToSharedNote', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMNoteStore::NoteStore_authenticateToSharedNote_args();
  $args->{guid} = $guid;
  $args->{noteKey} = $noteKey;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_authenticateToSharedNote{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMNoteStore::NoteStore_authenticateToSharedNote_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "authenticateToSharedNote failed: unknown result";
}
package EDAMNoteStore::NoteStoreProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_getSyncState {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getSyncState_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getSyncState_result();
    eval {
      $result->{success} = $self->{handler}->getSyncState($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('getSyncState', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getSyncChunk {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getSyncChunk_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getSyncChunk_result();
    eval {
      $result->{success} = $self->{handler}->getSyncChunk($args->authenticationToken, $args->afterUSN, $args->maxEntries, $args->fullSyncOnly);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('getSyncChunk', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getFilteredSyncChunk {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getFilteredSyncChunk_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getFilteredSyncChunk_result();
    eval {
      $result->{success} = $self->{handler}->getFilteredSyncChunk($args->authenticationToken, $args->afterUSN, $args->maxEntries, $args->filter);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('getFilteredSyncChunk', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getLinkedNotebookSyncState {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getLinkedNotebookSyncState_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getLinkedNotebookSyncState_result();
    eval {
      $result->{success} = $self->{handler}->getLinkedNotebookSyncState($args->authenticationToken, $args->linkedNotebook);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getLinkedNotebookSyncState', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getLinkedNotebookSyncChunk {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getLinkedNotebookSyncChunk_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getLinkedNotebookSyncChunk_result();
    eval {
      $result->{success} = $self->{handler}->getLinkedNotebookSyncChunk($args->authenticationToken, $args->linkedNotebook, $args->afterUSN, $args->maxEntries, $args->fullSyncOnly);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getLinkedNotebookSyncChunk', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_listNotebooks {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_listNotebooks_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_listNotebooks_result();
    eval {
      $result->{success} = $self->{handler}->listNotebooks($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('listNotebooks', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getNotebook_result();
    eval {
      $result->{success} = $self->{handler}->getNotebook($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getDefaultNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getDefaultNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getDefaultNotebook_result();
    eval {
      $result->{success} = $self->{handler}->getDefaultNotebook($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('getDefaultNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_createNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_createNotebook_result();
    eval {
      $result->{success} = $self->{handler}->createNotebook($args->authenticationToken, $args->notebook);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('createNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_updateNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_updateNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_updateNotebook_result();
    eval {
      $result->{success} = $self->{handler}->updateNotebook($args->authenticationToken, $args->notebook);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('updateNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_expungeNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_expungeNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_expungeNotebook_result();
    eval {
      $result->{success} = $self->{handler}->expungeNotebook($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('expungeNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_listTags {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_listTags_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_listTags_result();
    eval {
      $result->{success} = $self->{handler}->listTags($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('listTags', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_listTagsByNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_listTagsByNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_listTagsByNotebook_result();
    eval {
      $result->{success} = $self->{handler}->listTagsByNotebook($args->authenticationToken, $args->notebookGuid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('listTagsByNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getTag {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getTag_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getTag_result();
    eval {
      $result->{success} = $self->{handler}->getTag($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getTag', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createTag {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_createTag_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_createTag_result();
    eval {
      $result->{success} = $self->{handler}->createTag($args->authenticationToken, $args->tag);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('createTag', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_updateTag {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_updateTag_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_updateTag_result();
    eval {
      $result->{success} = $self->{handler}->updateTag($args->authenticationToken, $args->tag);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('updateTag', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_untagAll {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_untagAll_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_untagAll_result();
    eval {
      $self->{handler}->untagAll($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('untagAll', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_expungeTag {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_expungeTag_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_expungeTag_result();
    eval {
      $result->{success} = $self->{handler}->expungeTag($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('expungeTag', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_listSearches {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_listSearches_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_listSearches_result();
    eval {
      $result->{success} = $self->{handler}->listSearches($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('listSearches', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getSearch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getSearch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getSearch_result();
    eval {
      $result->{success} = $self->{handler}->getSearch($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getSearch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createSearch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_createSearch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_createSearch_result();
    eval {
      $result->{success} = $self->{handler}->createSearch($args->authenticationToken, $args->search);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('createSearch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_updateSearch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_updateSearch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_updateSearch_result();
    eval {
      $result->{success} = $self->{handler}->updateSearch($args->authenticationToken, $args->search);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('updateSearch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_expungeSearch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_expungeSearch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_expungeSearch_result();
    eval {
      $result->{success} = $self->{handler}->expungeSearch($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('expungeSearch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_findNotes {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_findNotes_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_findNotes_result();
    eval {
      $result->{success} = $self->{handler}->findNotes($args->authenticationToken, $args->filter, $args->offset, $args->maxNotes);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('findNotes', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_findNoteOffset {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_findNoteOffset_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_findNoteOffset_result();
    eval {
      $result->{success} = $self->{handler}->findNoteOffset($args->authenticationToken, $args->filter, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('findNoteOffset', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_findNotesMetadata {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_findNotesMetadata_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_findNotesMetadata_result();
    eval {
      $result->{success} = $self->{handler}->findNotesMetadata($args->authenticationToken, $args->filter, $args->offset, $args->maxNotes, $args->resultSpec);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('findNotesMetadata', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_findNoteCounts {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_findNoteCounts_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_findNoteCounts_result();
    eval {
      $result->{success} = $self->{handler}->findNoteCounts($args->authenticationToken, $args->filter, $args->withTrash);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('findNoteCounts', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getNote {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getNote_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getNote_result();
    eval {
      $result->{success} = $self->{handler}->getNote($args->authenticationToken, $args->guid, $args->withContent, $args->withResourcesData, $args->withResourcesRecognition, $args->withResourcesAlternateData);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getNote', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getNoteApplicationData {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getNoteApplicationData_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getNoteApplicationData_result();
    eval {
      $result->{success} = $self->{handler}->getNoteApplicationData($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getNoteApplicationData', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getNoteApplicationDataEntry {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getNoteApplicationDataEntry_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getNoteApplicationDataEntry_result();
    eval {
      $result->{success} = $self->{handler}->getNoteApplicationDataEntry($args->authenticationToken, $args->guid, $args->key);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getNoteApplicationDataEntry', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_setNoteApplicationDataEntry {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_setNoteApplicationDataEntry_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_setNoteApplicationDataEntry_result();
    eval {
      $result->{success} = $self->{handler}->setNoteApplicationDataEntry($args->authenticationToken, $args->guid, $args->key, $args->value);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('setNoteApplicationDataEntry', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_unsetNoteApplicationDataEntry {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_unsetNoteApplicationDataEntry_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_unsetNoteApplicationDataEntry_result();
    eval {
      $result->{success} = $self->{handler}->unsetNoteApplicationDataEntry($args->authenticationToken, $args->guid, $args->key);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('unsetNoteApplicationDataEntry', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getNoteContent {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getNoteContent_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getNoteContent_result();
    eval {
      $result->{success} = $self->{handler}->getNoteContent($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getNoteContent', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getNoteSearchText {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getNoteSearchText_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getNoteSearchText_result();
    eval {
      $result->{success} = $self->{handler}->getNoteSearchText($args->authenticationToken, $args->guid, $args->noteOnly, $args->tokenizeForIndexing);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getNoteSearchText', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getResourceSearchText {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getResourceSearchText_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getResourceSearchText_result();
    eval {
      $result->{success} = $self->{handler}->getResourceSearchText($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getResourceSearchText', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getNoteTagNames {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getNoteTagNames_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getNoteTagNames_result();
    eval {
      $result->{success} = $self->{handler}->getNoteTagNames($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getNoteTagNames', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createNote {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_createNote_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_createNote_result();
    eval {
      $result->{success} = $self->{handler}->createNote($args->authenticationToken, $args->note);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('createNote', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_updateNote {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_updateNote_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_updateNote_result();
    eval {
      $result->{success} = $self->{handler}->updateNote($args->authenticationToken, $args->note);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('updateNote', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteNote {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_deleteNote_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_deleteNote_result();
    eval {
      $result->{success} = $self->{handler}->deleteNote($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('deleteNote', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_expungeNote {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_expungeNote_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_expungeNote_result();
    eval {
      $result->{success} = $self->{handler}->expungeNote($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('expungeNote', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_expungeNotes {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_expungeNotes_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_expungeNotes_result();
    eval {
      $result->{success} = $self->{handler}->expungeNotes($args->authenticationToken, $args->noteGuids);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('expungeNotes', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_expungeInactiveNotes {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_expungeInactiveNotes_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_expungeInactiveNotes_result();
    eval {
      $result->{success} = $self->{handler}->expungeInactiveNotes($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('expungeInactiveNotes', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_copyNote {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_copyNote_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_copyNote_result();
    eval {
      $result->{success} = $self->{handler}->copyNote($args->authenticationToken, $args->noteGuid, $args->toNotebookGuid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('copyNote', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_listNoteVersions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_listNoteVersions_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_listNoteVersions_result();
    eval {
      $result->{success} = $self->{handler}->listNoteVersions($args->authenticationToken, $args->noteGuid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('listNoteVersions', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getNoteVersion {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getNoteVersion_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getNoteVersion_result();
    eval {
      $result->{success} = $self->{handler}->getNoteVersion($args->authenticationToken, $args->noteGuid, $args->updateSequenceNum, $args->withResourcesData, $args->withResourcesRecognition, $args->withResourcesAlternateData);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getNoteVersion', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getResource {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getResource_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getResource_result();
    eval {
      $result->{success} = $self->{handler}->getResource($args->authenticationToken, $args->guid, $args->withData, $args->withRecognition, $args->withAttributes, $args->withAlternateData);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getResource', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getResourceApplicationData {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getResourceApplicationData_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getResourceApplicationData_result();
    eval {
      $result->{success} = $self->{handler}->getResourceApplicationData($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getResourceApplicationData', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getResourceApplicationDataEntry {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getResourceApplicationDataEntry_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getResourceApplicationDataEntry_result();
    eval {
      $result->{success} = $self->{handler}->getResourceApplicationDataEntry($args->authenticationToken, $args->guid, $args->key);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getResourceApplicationDataEntry', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_setResourceApplicationDataEntry {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_setResourceApplicationDataEntry_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_setResourceApplicationDataEntry_result();
    eval {
      $result->{success} = $self->{handler}->setResourceApplicationDataEntry($args->authenticationToken, $args->guid, $args->key, $args->value);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('setResourceApplicationDataEntry', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_unsetResourceApplicationDataEntry {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_unsetResourceApplicationDataEntry_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_unsetResourceApplicationDataEntry_result();
    eval {
      $result->{success} = $self->{handler}->unsetResourceApplicationDataEntry($args->authenticationToken, $args->guid, $args->key);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('unsetResourceApplicationDataEntry', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_updateResource {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_updateResource_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_updateResource_result();
    eval {
      $result->{success} = $self->{handler}->updateResource($args->authenticationToken, $args->resource);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('updateResource', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getResourceData {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getResourceData_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getResourceData_result();
    eval {
      $result->{success} = $self->{handler}->getResourceData($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getResourceData', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getResourceByHash {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getResourceByHash_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getResourceByHash_result();
    eval {
      $result->{success} = $self->{handler}->getResourceByHash($args->authenticationToken, $args->noteGuid, $args->contentHash, $args->withData, $args->withRecognition, $args->withAlternateData);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getResourceByHash', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getResourceRecognition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getResourceRecognition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getResourceRecognition_result();
    eval {
      $result->{success} = $self->{handler}->getResourceRecognition($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getResourceRecognition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getResourceAlternateData {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getResourceAlternateData_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getResourceAlternateData_result();
    eval {
      $result->{success} = $self->{handler}->getResourceAlternateData($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getResourceAlternateData', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getResourceAttributes {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getResourceAttributes_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getResourceAttributes_result();
    eval {
      $result->{success} = $self->{handler}->getResourceAttributes($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getResourceAttributes', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getAccountSize {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getAccountSize_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getAccountSize_result();
    eval {
      $result->{success} = $self->{handler}->getAccountSize($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('getAccountSize', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getAds {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getAds_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getAds_result();
    eval {
      $result->{success} = $self->{handler}->getAds($args->authenticationToken, $args->adParameters);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('getAds', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRandomAd {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getRandomAd_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getRandomAd_result();
    eval {
      $result->{success} = $self->{handler}->getRandomAd($args->authenticationToken, $args->adParameters);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('getRandomAd', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getPublicNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getPublicNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getPublicNotebook_result();
    eval {
      $result->{success} = $self->{handler}->getPublicNotebook($args->userId, $args->publicUri);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
    }
    $output->writeMessageBegin('getPublicNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createSharedNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_createSharedNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_createSharedNotebook_result();
    eval {
      $result->{success} = $self->{handler}->createSharedNotebook($args->authenticationToken, $args->sharedNotebook);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('createSharedNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_sendMessageToSharedNotebookMembers {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_sendMessageToSharedNotebookMembers_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_sendMessageToSharedNotebookMembers_result();
    eval {
      $result->{success} = $self->{handler}->sendMessageToSharedNotebookMembers($args->authenticationToken, $args->notebookGuid, $args->messageText, $args->recipients);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('sendMessageToSharedNotebookMembers', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_listSharedNotebooks {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_listSharedNotebooks_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_listSharedNotebooks_result();
    eval {
      $result->{success} = $self->{handler}->listSharedNotebooks($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('listSharedNotebooks', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_expungeSharedNotebooks {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_expungeSharedNotebooks_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_expungeSharedNotebooks_result();
    eval {
      $result->{success} = $self->{handler}->expungeSharedNotebooks($args->authenticationToken, $args->sharedNotebookIds);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('expungeSharedNotebooks', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createLinkedNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_createLinkedNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_createLinkedNotebook_result();
    eval {
      $result->{success} = $self->{handler}->createLinkedNotebook($args->authenticationToken, $args->linkedNotebook);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('createLinkedNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_updateLinkedNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_updateLinkedNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_updateLinkedNotebook_result();
    eval {
      $result->{success} = $self->{handler}->updateLinkedNotebook($args->authenticationToken, $args->linkedNotebook);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('updateLinkedNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_listLinkedNotebooks {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_listLinkedNotebooks_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_listLinkedNotebooks_result();
    eval {
      $result->{success} = $self->{handler}->listLinkedNotebooks($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('listLinkedNotebooks', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_expungeLinkedNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_expungeLinkedNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_expungeLinkedNotebook_result();
    eval {
      $result->{success} = $self->{handler}->expungeLinkedNotebook($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('expungeLinkedNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_authenticateToSharedNotebook {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_authenticateToSharedNotebook_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_authenticateToSharedNotebook_result();
    eval {
      $result->{success} = $self->{handler}->authenticateToSharedNotebook($args->shareKey, $args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('authenticateToSharedNotebook', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getSharedNotebookByAuth {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_getSharedNotebookByAuth_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_getSharedNotebookByAuth_result();
    eval {
      $result->{success} = $self->{handler}->getSharedNotebookByAuth($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('getSharedNotebookByAuth', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_emailNote {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_emailNote_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_emailNote_result();
    eval {
      $self->{handler}->emailNote($args->authenticationToken, $args->parameters);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('emailNote', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shareNote {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_shareNote_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_shareNote_result();
    eval {
      $result->{success} = $self->{handler}->shareNote($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('shareNote', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_stopSharingNote {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_stopSharingNote_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_stopSharingNote_result();
    eval {
      $self->{handler}->stopSharingNote($args->authenticationToken, $args->guid);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('stopSharingNote', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_authenticateToSharedNote {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMNoteStore::NoteStore_authenticateToSharedNote_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMNoteStore::NoteStore_authenticateToSharedNote_result();
    eval {
      $result->{success} = $self->{handler}->authenticateToSharedNote($args->guid, $args->noteKey);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('authenticateToSharedNote', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;

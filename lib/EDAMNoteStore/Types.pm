#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package EDAMNoteStore::SyncState;
use base qw(Class::Accessor);
EDAMNoteStore::SyncState->mk_accessors( qw( currentTime fullSyncBefore updateCount uploaded ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{currentTime} = undef;
  $self->{fullSyncBefore} = undef;
  $self->{updateCount} = undef;
  $self->{uploaded} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{currentTime}) {
      $self->{currentTime} = $vals->{currentTime};
    }
    if (defined $vals->{fullSyncBefore}) {
      $self->{fullSyncBefore} = $vals->{fullSyncBefore};
    }
    if (defined $vals->{updateCount}) {
      $self->{updateCount} = $vals->{updateCount};
    }
    if (defined $vals->{uploaded}) {
      $self->{uploaded} = $vals->{uploaded};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SyncState';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{currentTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{fullSyncBefore});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{updateCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uploaded});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SyncState');
  if (defined $self->{currentTime}) {
    $xfer += $output->writeFieldBegin('currentTime', TType::I64, 1);
    $xfer += $output->writeI64($self->{currentTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fullSyncBefore}) {
    $xfer += $output->writeFieldBegin('fullSyncBefore', TType::I64, 2);
    $xfer += $output->writeI64($self->{fullSyncBefore});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updateCount}) {
    $xfer += $output->writeFieldBegin('updateCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{updateCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uploaded}) {
    $xfer += $output->writeFieldBegin('uploaded', TType::I64, 4);
    $xfer += $output->writeI64($self->{uploaded});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::SyncChunk;
use base qw(Class::Accessor);
EDAMNoteStore::SyncChunk->mk_accessors( qw( currentTime chunkHighUSN updateCount notes notebooks tags searches resources expungedNotes expungedNotebooks expungedTags expungedSearches linkedNotebooks expungedLinkedNotebooks ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{currentTime} = undef;
  $self->{chunkHighUSN} = undef;
  $self->{updateCount} = undef;
  $self->{notes} = undef;
  $self->{notebooks} = undef;
  $self->{tags} = undef;
  $self->{searches} = undef;
  $self->{resources} = undef;
  $self->{expungedNotes} = undef;
  $self->{expungedNotebooks} = undef;
  $self->{expungedTags} = undef;
  $self->{expungedSearches} = undef;
  $self->{linkedNotebooks} = undef;
  $self->{expungedLinkedNotebooks} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{currentTime}) {
      $self->{currentTime} = $vals->{currentTime};
    }
    if (defined $vals->{chunkHighUSN}) {
      $self->{chunkHighUSN} = $vals->{chunkHighUSN};
    }
    if (defined $vals->{updateCount}) {
      $self->{updateCount} = $vals->{updateCount};
    }
    if (defined $vals->{notes}) {
      $self->{notes} = $vals->{notes};
    }
    if (defined $vals->{notebooks}) {
      $self->{notebooks} = $vals->{notebooks};
    }
    if (defined $vals->{tags}) {
      $self->{tags} = $vals->{tags};
    }
    if (defined $vals->{searches}) {
      $self->{searches} = $vals->{searches};
    }
    if (defined $vals->{resources}) {
      $self->{resources} = $vals->{resources};
    }
    if (defined $vals->{expungedNotes}) {
      $self->{expungedNotes} = $vals->{expungedNotes};
    }
    if (defined $vals->{expungedNotebooks}) {
      $self->{expungedNotebooks} = $vals->{expungedNotebooks};
    }
    if (defined $vals->{expungedTags}) {
      $self->{expungedTags} = $vals->{expungedTags};
    }
    if (defined $vals->{expungedSearches}) {
      $self->{expungedSearches} = $vals->{expungedSearches};
    }
    if (defined $vals->{linkedNotebooks}) {
      $self->{linkedNotebooks} = $vals->{linkedNotebooks};
    }
    if (defined $vals->{expungedLinkedNotebooks}) {
      $self->{expungedLinkedNotebooks} = $vals->{expungedLinkedNotebooks};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SyncChunk';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{currentTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{chunkHighUSN});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{updateCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{notes} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new EDAMTypes::Note();
            $xfer += $elem5->read($input);
            push(@{$self->{notes}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size6 = 0;
          $self->{notebooks} = [];
          my $_etype9 = 0;
          $xfer += $input->readListBegin(\$_etype9, \$_size6);
          for (my $_i10 = 0; $_i10 < $_size6; ++$_i10)
          {
            my $elem11 = undef;
            $elem11 = new EDAMTypes::Notebook();
            $xfer += $elem11->read($input);
            push(@{$self->{notebooks}},$elem11);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size12 = 0;
          $self->{tags} = [];
          my $_etype15 = 0;
          $xfer += $input->readListBegin(\$_etype15, \$_size12);
          for (my $_i16 = 0; $_i16 < $_size12; ++$_i16)
          {
            my $elem17 = undef;
            $elem17 = new EDAMTypes::Tag();
            $xfer += $elem17->read($input);
            push(@{$self->{tags}},$elem17);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size18 = 0;
          $self->{searches} = [];
          my $_etype21 = 0;
          $xfer += $input->readListBegin(\$_etype21, \$_size18);
          for (my $_i22 = 0; $_i22 < $_size18; ++$_i22)
          {
            my $elem23 = undef;
            $elem23 = new EDAMTypes::SavedSearch();
            $xfer += $elem23->read($input);
            push(@{$self->{searches}},$elem23);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size24 = 0;
          $self->{resources} = [];
          my $_etype27 = 0;
          $xfer += $input->readListBegin(\$_etype27, \$_size24);
          for (my $_i28 = 0; $_i28 < $_size24; ++$_i28)
          {
            my $elem29 = undef;
            $elem29 = new EDAMTypes::Resource();
            $xfer += $elem29->read($input);
            push(@{$self->{resources}},$elem29);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size30 = 0;
          $self->{expungedNotes} = [];
          my $_etype33 = 0;
          $xfer += $input->readListBegin(\$_etype33, \$_size30);
          for (my $_i34 = 0; $_i34 < $_size30; ++$_i34)
          {
            my $elem35 = undef;
            $xfer += $input->readString(\$elem35);
            push(@{$self->{expungedNotes}},$elem35);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size36 = 0;
          $self->{expungedNotebooks} = [];
          my $_etype39 = 0;
          $xfer += $input->readListBegin(\$_etype39, \$_size36);
          for (my $_i40 = 0; $_i40 < $_size36; ++$_i40)
          {
            my $elem41 = undef;
            $xfer += $input->readString(\$elem41);
            push(@{$self->{expungedNotebooks}},$elem41);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size42 = 0;
          $self->{expungedTags} = [];
          my $_etype45 = 0;
          $xfer += $input->readListBegin(\$_etype45, \$_size42);
          for (my $_i46 = 0; $_i46 < $_size42; ++$_i46)
          {
            my $elem47 = undef;
            $xfer += $input->readString(\$elem47);
            push(@{$self->{expungedTags}},$elem47);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size48 = 0;
          $self->{expungedSearches} = [];
          my $_etype51 = 0;
          $xfer += $input->readListBegin(\$_etype51, \$_size48);
          for (my $_i52 = 0; $_i52 < $_size48; ++$_i52)
          {
            my $elem53 = undef;
            $xfer += $input->readString(\$elem53);
            push(@{$self->{expungedSearches}},$elem53);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size54 = 0;
          $self->{linkedNotebooks} = [];
          my $_etype57 = 0;
          $xfer += $input->readListBegin(\$_etype57, \$_size54);
          for (my $_i58 = 0; $_i58 < $_size54; ++$_i58)
          {
            my $elem59 = undef;
            $elem59 = new EDAMTypes::LinkedNotebook();
            $xfer += $elem59->read($input);
            push(@{$self->{linkedNotebooks}},$elem59);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size60 = 0;
          $self->{expungedLinkedNotebooks} = [];
          my $_etype63 = 0;
          $xfer += $input->readListBegin(\$_etype63, \$_size60);
          for (my $_i64 = 0; $_i64 < $_size60; ++$_i64)
          {
            my $elem65 = undef;
            $xfer += $input->readString(\$elem65);
            push(@{$self->{expungedLinkedNotebooks}},$elem65);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SyncChunk');
  if (defined $self->{currentTime}) {
    $xfer += $output->writeFieldBegin('currentTime', TType::I64, 1);
    $xfer += $output->writeI64($self->{currentTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{chunkHighUSN}) {
    $xfer += $output->writeFieldBegin('chunkHighUSN', TType::I32, 2);
    $xfer += $output->writeI32($self->{chunkHighUSN});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updateCount}) {
    $xfer += $output->writeFieldBegin('updateCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{updateCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notes}) {
    $xfer += $output->writeFieldBegin('notes', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{notes}}));
      {
        foreach my $iter66 (@{$self->{notes}}) 
        {
          $xfer += ${iter66}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notebooks}) {
    $xfer += $output->writeFieldBegin('notebooks', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{notebooks}}));
      {
        foreach my $iter67 (@{$self->{notebooks}}) 
        {
          $xfer += ${iter67}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tags}) {
    $xfer += $output->writeFieldBegin('tags', TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{tags}}));
      {
        foreach my $iter68 (@{$self->{tags}}) 
        {
          $xfer += ${iter68}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{searches}) {
    $xfer += $output->writeFieldBegin('searches', TType::LIST, 7);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{searches}}));
      {
        foreach my $iter69 (@{$self->{searches}}) 
        {
          $xfer += ${iter69}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{resources}) {
    $xfer += $output->writeFieldBegin('resources', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{resources}}));
      {
        foreach my $iter70 (@{$self->{resources}}) 
        {
          $xfer += ${iter70}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expungedNotes}) {
    $xfer += $output->writeFieldBegin('expungedNotes', TType::LIST, 9);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{expungedNotes}}));
      {
        foreach my $iter71 (@{$self->{expungedNotes}}) 
        {
          $xfer += $output->writeString($iter71);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expungedNotebooks}) {
    $xfer += $output->writeFieldBegin('expungedNotebooks', TType::LIST, 10);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{expungedNotebooks}}));
      {
        foreach my $iter72 (@{$self->{expungedNotebooks}}) 
        {
          $xfer += $output->writeString($iter72);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expungedTags}) {
    $xfer += $output->writeFieldBegin('expungedTags', TType::LIST, 11);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{expungedTags}}));
      {
        foreach my $iter73 (@{$self->{expungedTags}}) 
        {
          $xfer += $output->writeString($iter73);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expungedSearches}) {
    $xfer += $output->writeFieldBegin('expungedSearches', TType::LIST, 12);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{expungedSearches}}));
      {
        foreach my $iter74 (@{$self->{expungedSearches}}) 
        {
          $xfer += $output->writeString($iter74);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{linkedNotebooks}) {
    $xfer += $output->writeFieldBegin('linkedNotebooks', TType::LIST, 13);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{linkedNotebooks}}));
      {
        foreach my $iter75 (@{$self->{linkedNotebooks}}) 
        {
          $xfer += ${iter75}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expungedLinkedNotebooks}) {
    $xfer += $output->writeFieldBegin('expungedLinkedNotebooks', TType::LIST, 14);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{expungedLinkedNotebooks}}));
      {
        foreach my $iter76 (@{$self->{expungedLinkedNotebooks}}) 
        {
          $xfer += $output->writeString($iter76);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::SyncChunkFilter;
use base qw(Class::Accessor);
EDAMNoteStore::SyncChunkFilter->mk_accessors( qw( includeNotes includeNoteResources includeNoteAttributes includeNotebooks includeTags includeSearches includeResources includeLinkedNotebooks includeExpunged includeNoteApplicationDataFullMap includeResourceApplicationDataFullMap includeNoteResourceApplicationDataFullMap requireNoteContentClass ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{includeNotes} = undef;
  $self->{includeNoteResources} = undef;
  $self->{includeNoteAttributes} = undef;
  $self->{includeNotebooks} = undef;
  $self->{includeTags} = undef;
  $self->{includeSearches} = undef;
  $self->{includeResources} = undef;
  $self->{includeLinkedNotebooks} = undef;
  $self->{includeExpunged} = undef;
  $self->{includeNoteApplicationDataFullMap} = undef;
  $self->{includeResourceApplicationDataFullMap} = undef;
  $self->{includeNoteResourceApplicationDataFullMap} = undef;
  $self->{requireNoteContentClass} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{includeNotes}) {
      $self->{includeNotes} = $vals->{includeNotes};
    }
    if (defined $vals->{includeNoteResources}) {
      $self->{includeNoteResources} = $vals->{includeNoteResources};
    }
    if (defined $vals->{includeNoteAttributes}) {
      $self->{includeNoteAttributes} = $vals->{includeNoteAttributes};
    }
    if (defined $vals->{includeNotebooks}) {
      $self->{includeNotebooks} = $vals->{includeNotebooks};
    }
    if (defined $vals->{includeTags}) {
      $self->{includeTags} = $vals->{includeTags};
    }
    if (defined $vals->{includeSearches}) {
      $self->{includeSearches} = $vals->{includeSearches};
    }
    if (defined $vals->{includeResources}) {
      $self->{includeResources} = $vals->{includeResources};
    }
    if (defined $vals->{includeLinkedNotebooks}) {
      $self->{includeLinkedNotebooks} = $vals->{includeLinkedNotebooks};
    }
    if (defined $vals->{includeExpunged}) {
      $self->{includeExpunged} = $vals->{includeExpunged};
    }
    if (defined $vals->{includeNoteApplicationDataFullMap}) {
      $self->{includeNoteApplicationDataFullMap} = $vals->{includeNoteApplicationDataFullMap};
    }
    if (defined $vals->{includeResourceApplicationDataFullMap}) {
      $self->{includeResourceApplicationDataFullMap} = $vals->{includeResourceApplicationDataFullMap};
    }
    if (defined $vals->{includeNoteResourceApplicationDataFullMap}) {
      $self->{includeNoteResourceApplicationDataFullMap} = $vals->{includeNoteResourceApplicationDataFullMap};
    }
    if (defined $vals->{requireNoteContentClass}) {
      $self->{requireNoteContentClass} = $vals->{requireNoteContentClass};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SyncChunkFilter';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeNotes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeNoteResources});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeNoteAttributes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeNotebooks});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeTags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeSearches});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeResources});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeLinkedNotebooks});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeExpunged});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeNoteApplicationDataFullMap});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeResourceApplicationDataFullMap});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeNoteResourceApplicationDataFullMap});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{requireNoteContentClass});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SyncChunkFilter');
  if (defined $self->{includeNotes}) {
    $xfer += $output->writeFieldBegin('includeNotes', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{includeNotes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeNoteResources}) {
    $xfer += $output->writeFieldBegin('includeNoteResources', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{includeNoteResources});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeNoteAttributes}) {
    $xfer += $output->writeFieldBegin('includeNoteAttributes', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{includeNoteAttributes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeNotebooks}) {
    $xfer += $output->writeFieldBegin('includeNotebooks', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{includeNotebooks});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeTags}) {
    $xfer += $output->writeFieldBegin('includeTags', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{includeTags});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeSearches}) {
    $xfer += $output->writeFieldBegin('includeSearches', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{includeSearches});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeResources}) {
    $xfer += $output->writeFieldBegin('includeResources', TType::BOOL, 7);
    $xfer += $output->writeBool($self->{includeResources});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeLinkedNotebooks}) {
    $xfer += $output->writeFieldBegin('includeLinkedNotebooks', TType::BOOL, 8);
    $xfer += $output->writeBool($self->{includeLinkedNotebooks});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeExpunged}) {
    $xfer += $output->writeFieldBegin('includeExpunged', TType::BOOL, 9);
    $xfer += $output->writeBool($self->{includeExpunged});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeNoteApplicationDataFullMap}) {
    $xfer += $output->writeFieldBegin('includeNoteApplicationDataFullMap', TType::BOOL, 10);
    $xfer += $output->writeBool($self->{includeNoteApplicationDataFullMap});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{requireNoteContentClass}) {
    $xfer += $output->writeFieldBegin('requireNoteContentClass', TType::STRING, 11);
    $xfer += $output->writeString($self->{requireNoteContentClass});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeResourceApplicationDataFullMap}) {
    $xfer += $output->writeFieldBegin('includeResourceApplicationDataFullMap', TType::BOOL, 12);
    $xfer += $output->writeBool($self->{includeResourceApplicationDataFullMap});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeNoteResourceApplicationDataFullMap}) {
    $xfer += $output->writeFieldBegin('includeNoteResourceApplicationDataFullMap', TType::BOOL, 13);
    $xfer += $output->writeBool($self->{includeNoteResourceApplicationDataFullMap});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteFilter;
use base qw(Class::Accessor);
EDAMNoteStore::NoteFilter->mk_accessors( qw( order ascending words notebookGuid tagGuids timeZone inactive ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{order} = undef;
  $self->{ascending} = undef;
  $self->{words} = undef;
  $self->{notebookGuid} = undef;
  $self->{tagGuids} = undef;
  $self->{timeZone} = undef;
  $self->{inactive} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{order}) {
      $self->{order} = $vals->{order};
    }
    if (defined $vals->{ascending}) {
      $self->{ascending} = $vals->{ascending};
    }
    if (defined $vals->{words}) {
      $self->{words} = $vals->{words};
    }
    if (defined $vals->{notebookGuid}) {
      $self->{notebookGuid} = $vals->{notebookGuid};
    }
    if (defined $vals->{tagGuids}) {
      $self->{tagGuids} = $vals->{tagGuids};
    }
    if (defined $vals->{timeZone}) {
      $self->{timeZone} = $vals->{timeZone};
    }
    if (defined $vals->{inactive}) {
      $self->{inactive} = $vals->{inactive};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteFilter';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{order});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{ascending});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{words});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{notebookGuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size77 = 0;
          $self->{tagGuids} = [];
          my $_etype80 = 0;
          $xfer += $input->readListBegin(\$_etype80, \$_size77);
          for (my $_i81 = 0; $_i81 < $_size77; ++$_i81)
          {
            my $elem82 = undef;
            $xfer += $input->readString(\$elem82);
            push(@{$self->{tagGuids}},$elem82);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{timeZone});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{inactive});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteFilter');
  if (defined $self->{order}) {
    $xfer += $output->writeFieldBegin('order', TType::I32, 1);
    $xfer += $output->writeI32($self->{order});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ascending}) {
    $xfer += $output->writeFieldBegin('ascending', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{ascending});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{words}) {
    $xfer += $output->writeFieldBegin('words', TType::STRING, 3);
    $xfer += $output->writeString($self->{words});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notebookGuid}) {
    $xfer += $output->writeFieldBegin('notebookGuid', TType::STRING, 4);
    $xfer += $output->writeString($self->{notebookGuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tagGuids}) {
    $xfer += $output->writeFieldBegin('tagGuids', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{tagGuids}}));
      {
        foreach my $iter83 (@{$self->{tagGuids}}) 
        {
          $xfer += $output->writeString($iter83);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeZone}) {
    $xfer += $output->writeFieldBegin('timeZone', TType::STRING, 6);
    $xfer += $output->writeString($self->{timeZone});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{inactive}) {
    $xfer += $output->writeFieldBegin('inactive', TType::BOOL, 7);
    $xfer += $output->writeBool($self->{inactive});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteList;
use base qw(Class::Accessor);
EDAMNoteStore::NoteList->mk_accessors( qw( startIndex totalNotes notes stoppedWords searchedWords updateCount ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{startIndex} = undef;
  $self->{totalNotes} = undef;
  $self->{notes} = undef;
  $self->{stoppedWords} = undef;
  $self->{searchedWords} = undef;
  $self->{updateCount} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{startIndex}) {
      $self->{startIndex} = $vals->{startIndex};
    }
    if (defined $vals->{totalNotes}) {
      $self->{totalNotes} = $vals->{totalNotes};
    }
    if (defined $vals->{notes}) {
      $self->{notes} = $vals->{notes};
    }
    if (defined $vals->{stoppedWords}) {
      $self->{stoppedWords} = $vals->{stoppedWords};
    }
    if (defined $vals->{searchedWords}) {
      $self->{searchedWords} = $vals->{searchedWords};
    }
    if (defined $vals->{updateCount}) {
      $self->{updateCount} = $vals->{updateCount};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteList';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{startIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{totalNotes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size84 = 0;
          $self->{notes} = [];
          my $_etype87 = 0;
          $xfer += $input->readListBegin(\$_etype87, \$_size84);
          for (my $_i88 = 0; $_i88 < $_size84; ++$_i88)
          {
            my $elem89 = undef;
            $elem89 = new EDAMTypes::Note();
            $xfer += $elem89->read($input);
            push(@{$self->{notes}},$elem89);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size90 = 0;
          $self->{stoppedWords} = [];
          my $_etype93 = 0;
          $xfer += $input->readListBegin(\$_etype93, \$_size90);
          for (my $_i94 = 0; $_i94 < $_size90; ++$_i94)
          {
            my $elem95 = undef;
            $xfer += $input->readString(\$elem95);
            push(@{$self->{stoppedWords}},$elem95);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size96 = 0;
          $self->{searchedWords} = [];
          my $_etype99 = 0;
          $xfer += $input->readListBegin(\$_etype99, \$_size96);
          for (my $_i100 = 0; $_i100 < $_size96; ++$_i100)
          {
            my $elem101 = undef;
            $xfer += $input->readString(\$elem101);
            push(@{$self->{searchedWords}},$elem101);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{updateCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteList');
  if (defined $self->{startIndex}) {
    $xfer += $output->writeFieldBegin('startIndex', TType::I32, 1);
    $xfer += $output->writeI32($self->{startIndex});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{totalNotes}) {
    $xfer += $output->writeFieldBegin('totalNotes', TType::I32, 2);
    $xfer += $output->writeI32($self->{totalNotes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notes}) {
    $xfer += $output->writeFieldBegin('notes', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{notes}}));
      {
        foreach my $iter102 (@{$self->{notes}}) 
        {
          $xfer += ${iter102}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stoppedWords}) {
    $xfer += $output->writeFieldBegin('stoppedWords', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{stoppedWords}}));
      {
        foreach my $iter103 (@{$self->{stoppedWords}}) 
        {
          $xfer += $output->writeString($iter103);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{searchedWords}) {
    $xfer += $output->writeFieldBegin('searchedWords', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{searchedWords}}));
      {
        foreach my $iter104 (@{$self->{searchedWords}}) 
        {
          $xfer += $output->writeString($iter104);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updateCount}) {
    $xfer += $output->writeFieldBegin('updateCount', TType::I32, 6);
    $xfer += $output->writeI32($self->{updateCount});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteMetadata;
use base qw(Class::Accessor);
EDAMNoteStore::NoteMetadata->mk_accessors( qw( guid title contentLength created updated updateSequenceNum notebookGuid tagGuids attributes largestResourceMime largestResourceSize ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{guid} = undef;
  $self->{title} = undef;
  $self->{contentLength} = undef;
  $self->{created} = undef;
  $self->{updated} = undef;
  $self->{updateSequenceNum} = undef;
  $self->{notebookGuid} = undef;
  $self->{tagGuids} = undef;
  $self->{attributes} = undef;
  $self->{largestResourceMime} = undef;
  $self->{largestResourceSize} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{title}) {
      $self->{title} = $vals->{title};
    }
    if (defined $vals->{contentLength}) {
      $self->{contentLength} = $vals->{contentLength};
    }
    if (defined $vals->{created}) {
      $self->{created} = $vals->{created};
    }
    if (defined $vals->{updated}) {
      $self->{updated} = $vals->{updated};
    }
    if (defined $vals->{updateSequenceNum}) {
      $self->{updateSequenceNum} = $vals->{updateSequenceNum};
    }
    if (defined $vals->{notebookGuid}) {
      $self->{notebookGuid} = $vals->{notebookGuid};
    }
    if (defined $vals->{tagGuids}) {
      $self->{tagGuids} = $vals->{tagGuids};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
    if (defined $vals->{largestResourceMime}) {
      $self->{largestResourceMime} = $vals->{largestResourceMime};
    }
    if (defined $vals->{largestResourceSize}) {
      $self->{largestResourceSize} = $vals->{largestResourceSize};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteMetadata';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{title});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{contentLength});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{created});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{updated});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{updateSequenceNum});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{notebookGuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size105 = 0;
          $self->{tagGuids} = [];
          my $_etype108 = 0;
          $xfer += $input->readListBegin(\$_etype108, \$_size105);
          for (my $_i109 = 0; $_i109 < $_size105; ++$_i109)
          {
            my $elem110 = undef;
            $xfer += $input->readString(\$elem110);
            push(@{$self->{tagGuids}},$elem110);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{attributes} = new EDAMTypes::NoteAttributes();
        $xfer += $self->{attributes}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^20$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{largestResourceMime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^21$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{largestResourceSize});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteMetadata');
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 1);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{title}) {
    $xfer += $output->writeFieldBegin('title', TType::STRING, 2);
    $xfer += $output->writeString($self->{title});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{contentLength}) {
    $xfer += $output->writeFieldBegin('contentLength', TType::I32, 5);
    $xfer += $output->writeI32($self->{contentLength});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{created}) {
    $xfer += $output->writeFieldBegin('created', TType::I64, 6);
    $xfer += $output->writeI64($self->{created});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updated}) {
    $xfer += $output->writeFieldBegin('updated', TType::I64, 7);
    $xfer += $output->writeI64($self->{updated});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updateSequenceNum}) {
    $xfer += $output->writeFieldBegin('updateSequenceNum', TType::I32, 10);
    $xfer += $output->writeI32($self->{updateSequenceNum});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notebookGuid}) {
    $xfer += $output->writeFieldBegin('notebookGuid', TType::STRING, 11);
    $xfer += $output->writeString($self->{notebookGuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tagGuids}) {
    $xfer += $output->writeFieldBegin('tagGuids', TType::LIST, 12);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{tagGuids}}));
      {
        foreach my $iter111 (@{$self->{tagGuids}}) 
        {
          $xfer += $output->writeString($iter111);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 14);
    $xfer += $self->{attributes}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{largestResourceMime}) {
    $xfer += $output->writeFieldBegin('largestResourceMime', TType::STRING, 20);
    $xfer += $output->writeString($self->{largestResourceMime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{largestResourceSize}) {
    $xfer += $output->writeFieldBegin('largestResourceSize', TType::I32, 21);
    $xfer += $output->writeI32($self->{largestResourceSize});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NotesMetadataList;
use base qw(Class::Accessor);
EDAMNoteStore::NotesMetadataList->mk_accessors( qw( startIndex totalNotes notes stoppedWords searchedWords updateCount ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{startIndex} = undef;
  $self->{totalNotes} = undef;
  $self->{notes} = undef;
  $self->{stoppedWords} = undef;
  $self->{searchedWords} = undef;
  $self->{updateCount} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{startIndex}) {
      $self->{startIndex} = $vals->{startIndex};
    }
    if (defined $vals->{totalNotes}) {
      $self->{totalNotes} = $vals->{totalNotes};
    }
    if (defined $vals->{notes}) {
      $self->{notes} = $vals->{notes};
    }
    if (defined $vals->{stoppedWords}) {
      $self->{stoppedWords} = $vals->{stoppedWords};
    }
    if (defined $vals->{searchedWords}) {
      $self->{searchedWords} = $vals->{searchedWords};
    }
    if (defined $vals->{updateCount}) {
      $self->{updateCount} = $vals->{updateCount};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NotesMetadataList';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{startIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{totalNotes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size112 = 0;
          $self->{notes} = [];
          my $_etype115 = 0;
          $xfer += $input->readListBegin(\$_etype115, \$_size112);
          for (my $_i116 = 0; $_i116 < $_size112; ++$_i116)
          {
            my $elem117 = undef;
            $elem117 = new EDAMNoteStore::NoteMetadata();
            $xfer += $elem117->read($input);
            push(@{$self->{notes}},$elem117);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size118 = 0;
          $self->{stoppedWords} = [];
          my $_etype121 = 0;
          $xfer += $input->readListBegin(\$_etype121, \$_size118);
          for (my $_i122 = 0; $_i122 < $_size118; ++$_i122)
          {
            my $elem123 = undef;
            $xfer += $input->readString(\$elem123);
            push(@{$self->{stoppedWords}},$elem123);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size124 = 0;
          $self->{searchedWords} = [];
          my $_etype127 = 0;
          $xfer += $input->readListBegin(\$_etype127, \$_size124);
          for (my $_i128 = 0; $_i128 < $_size124; ++$_i128)
          {
            my $elem129 = undef;
            $xfer += $input->readString(\$elem129);
            push(@{$self->{searchedWords}},$elem129);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{updateCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NotesMetadataList');
  if (defined $self->{startIndex}) {
    $xfer += $output->writeFieldBegin('startIndex', TType::I32, 1);
    $xfer += $output->writeI32($self->{startIndex});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{totalNotes}) {
    $xfer += $output->writeFieldBegin('totalNotes', TType::I32, 2);
    $xfer += $output->writeI32($self->{totalNotes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notes}) {
    $xfer += $output->writeFieldBegin('notes', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{notes}}));
      {
        foreach my $iter130 (@{$self->{notes}}) 
        {
          $xfer += ${iter130}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stoppedWords}) {
    $xfer += $output->writeFieldBegin('stoppedWords', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{stoppedWords}}));
      {
        foreach my $iter131 (@{$self->{stoppedWords}}) 
        {
          $xfer += $output->writeString($iter131);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{searchedWords}) {
    $xfer += $output->writeFieldBegin('searchedWords', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{searchedWords}}));
      {
        foreach my $iter132 (@{$self->{searchedWords}}) 
        {
          $xfer += $output->writeString($iter132);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updateCount}) {
    $xfer += $output->writeFieldBegin('updateCount', TType::I32, 6);
    $xfer += $output->writeI32($self->{updateCount});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NotesMetadataResultSpec;
use base qw(Class::Accessor);
EDAMNoteStore::NotesMetadataResultSpec->mk_accessors( qw( includeTitle includeContentLength includeCreated includeUpdated includeUpdateSequenceNum includeNotebookGuid includeTagGuids includeAttributes includeLargestResourceMime includeLargestResourceSize ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{includeTitle} = undef;
  $self->{includeContentLength} = undef;
  $self->{includeCreated} = undef;
  $self->{includeUpdated} = undef;
  $self->{includeUpdateSequenceNum} = undef;
  $self->{includeNotebookGuid} = undef;
  $self->{includeTagGuids} = undef;
  $self->{includeAttributes} = undef;
  $self->{includeLargestResourceMime} = undef;
  $self->{includeLargestResourceSize} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{includeTitle}) {
      $self->{includeTitle} = $vals->{includeTitle};
    }
    if (defined $vals->{includeContentLength}) {
      $self->{includeContentLength} = $vals->{includeContentLength};
    }
    if (defined $vals->{includeCreated}) {
      $self->{includeCreated} = $vals->{includeCreated};
    }
    if (defined $vals->{includeUpdated}) {
      $self->{includeUpdated} = $vals->{includeUpdated};
    }
    if (defined $vals->{includeUpdateSequenceNum}) {
      $self->{includeUpdateSequenceNum} = $vals->{includeUpdateSequenceNum};
    }
    if (defined $vals->{includeNotebookGuid}) {
      $self->{includeNotebookGuid} = $vals->{includeNotebookGuid};
    }
    if (defined $vals->{includeTagGuids}) {
      $self->{includeTagGuids} = $vals->{includeTagGuids};
    }
    if (defined $vals->{includeAttributes}) {
      $self->{includeAttributes} = $vals->{includeAttributes};
    }
    if (defined $vals->{includeLargestResourceMime}) {
      $self->{includeLargestResourceMime} = $vals->{includeLargestResourceMime};
    }
    if (defined $vals->{includeLargestResourceSize}) {
      $self->{includeLargestResourceSize} = $vals->{includeLargestResourceSize};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NotesMetadataResultSpec';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeTitle});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeContentLength});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeCreated});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeUpdated});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeUpdateSequenceNum});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeNotebookGuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeTagGuids});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeAttributes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^20$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeLargestResourceMime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^21$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{includeLargestResourceSize});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NotesMetadataResultSpec');
  if (defined $self->{includeTitle}) {
    $xfer += $output->writeFieldBegin('includeTitle', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{includeTitle});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeContentLength}) {
    $xfer += $output->writeFieldBegin('includeContentLength', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{includeContentLength});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeCreated}) {
    $xfer += $output->writeFieldBegin('includeCreated', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{includeCreated});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeUpdated}) {
    $xfer += $output->writeFieldBegin('includeUpdated', TType::BOOL, 7);
    $xfer += $output->writeBool($self->{includeUpdated});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeUpdateSequenceNum}) {
    $xfer += $output->writeFieldBegin('includeUpdateSequenceNum', TType::BOOL, 10);
    $xfer += $output->writeBool($self->{includeUpdateSequenceNum});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeNotebookGuid}) {
    $xfer += $output->writeFieldBegin('includeNotebookGuid', TType::BOOL, 11);
    $xfer += $output->writeBool($self->{includeNotebookGuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeTagGuids}) {
    $xfer += $output->writeFieldBegin('includeTagGuids', TType::BOOL, 12);
    $xfer += $output->writeBool($self->{includeTagGuids});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeAttributes}) {
    $xfer += $output->writeFieldBegin('includeAttributes', TType::BOOL, 14);
    $xfer += $output->writeBool($self->{includeAttributes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeLargestResourceMime}) {
    $xfer += $output->writeFieldBegin('includeLargestResourceMime', TType::BOOL, 20);
    $xfer += $output->writeBool($self->{includeLargestResourceMime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{includeLargestResourceSize}) {
    $xfer += $output->writeFieldBegin('includeLargestResourceSize', TType::BOOL, 21);
    $xfer += $output->writeBool($self->{includeLargestResourceSize});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteCollectionCounts;
use base qw(Class::Accessor);
EDAMNoteStore::NoteCollectionCounts->mk_accessors( qw( notebookCounts tagCounts trashCount ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{notebookCounts} = undef;
  $self->{tagCounts} = undef;
  $self->{trashCount} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{notebookCounts}) {
      $self->{notebookCounts} = $vals->{notebookCounts};
    }
    if (defined $vals->{tagCounts}) {
      $self->{tagCounts} = $vals->{tagCounts};
    }
    if (defined $vals->{trashCount}) {
      $self->{trashCount} = $vals->{trashCount};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteCollectionCounts';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size133 = 0;
          $self->{notebookCounts} = {};
          my $_ktype134 = 0;
          my $_vtype135 = 0;
          $xfer += $input->readMapBegin(\$_ktype134, \$_vtype135, \$_size133);
          for (my $_i137 = 0; $_i137 < $_size133; ++$_i137)
          {
            my $key138 = '';
            my $val139 = 0;
            $xfer += $input->readString(\$key138);
            $xfer += $input->readI32(\$val139);
            $self->{notebookCounts}->{$key138} = $val139;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size140 = 0;
          $self->{tagCounts} = {};
          my $_ktype141 = 0;
          my $_vtype142 = 0;
          $xfer += $input->readMapBegin(\$_ktype141, \$_vtype142, \$_size140);
          for (my $_i144 = 0; $_i144 < $_size140; ++$_i144)
          {
            my $key145 = '';
            my $val146 = 0;
            $xfer += $input->readString(\$key145);
            $xfer += $input->readI32(\$val146);
            $self->{tagCounts}->{$key145} = $val146;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{trashCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteCollectionCounts');
  if (defined $self->{notebookCounts}) {
    $xfer += $output->writeFieldBegin('notebookCounts', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{$self->{notebookCounts}}));
      {
        while( my ($kiter147,$viter148) = each %{$self->{notebookCounts}}) 
        {
          $xfer += $output->writeString($kiter147);
          $xfer += $output->writeI32($viter148);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tagCounts}) {
    $xfer += $output->writeFieldBegin('tagCounts', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{$self->{tagCounts}}));
      {
        while( my ($kiter149,$viter150) = each %{$self->{tagCounts}}) 
        {
          $xfer += $output->writeString($kiter149);
          $xfer += $output->writeI32($viter150);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{trashCount}) {
    $xfer += $output->writeFieldBegin('trashCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{trashCount});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::AdImpressions;
use base qw(Class::Accessor);
EDAMNoteStore::AdImpressions->mk_accessors( qw( adId impressionCount impressionTime ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{adId} = undef;
  $self->{impressionCount} = undef;
  $self->{impressionTime} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{adId}) {
      $self->{adId} = $vals->{adId};
    }
    if (defined $vals->{impressionCount}) {
      $self->{impressionCount} = $vals->{impressionCount};
    }
    if (defined $vals->{impressionTime}) {
      $self->{impressionTime} = $vals->{impressionTime};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AdImpressions';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{adId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{impressionCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{impressionTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AdImpressions');
  if (defined $self->{adId}) {
    $xfer += $output->writeFieldBegin('adId', TType::I32, 1);
    $xfer += $output->writeI32($self->{adId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{impressionCount}) {
    $xfer += $output->writeFieldBegin('impressionCount', TType::I32, 2);
    $xfer += $output->writeI32($self->{impressionCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{impressionTime}) {
    $xfer += $output->writeFieldBegin('impressionTime', TType::I32, 3);
    $xfer += $output->writeI32($self->{impressionTime});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::AdParameters;
use base qw(Class::Accessor);
EDAMNoteStore::AdParameters->mk_accessors( qw( clientLanguage impressions supportHtml clientProperties ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{clientLanguage} = undef;
  $self->{impressions} = undef;
  $self->{supportHtml} = undef;
  $self->{clientProperties} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{clientLanguage}) {
      $self->{clientLanguage} = $vals->{clientLanguage};
    }
    if (defined $vals->{impressions}) {
      $self->{impressions} = $vals->{impressions};
    }
    if (defined $vals->{supportHtml}) {
      $self->{supportHtml} = $vals->{supportHtml};
    }
    if (defined $vals->{clientProperties}) {
      $self->{clientProperties} = $vals->{clientProperties};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AdParameters';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{clientLanguage});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size151 = 0;
          $self->{impressions} = [];
          my $_etype154 = 0;
          $xfer += $input->readListBegin(\$_etype154, \$_size151);
          for (my $_i155 = 0; $_i155 < $_size151; ++$_i155)
          {
            my $elem156 = undef;
            $elem156 = new EDAMNoteStore::AdImpressions();
            $xfer += $elem156->read($input);
            push(@{$self->{impressions}},$elem156);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{supportHtml});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size157 = 0;
          $self->{clientProperties} = {};
          my $_ktype158 = 0;
          my $_vtype159 = 0;
          $xfer += $input->readMapBegin(\$_ktype158, \$_vtype159, \$_size157);
          for (my $_i161 = 0; $_i161 < $_size157; ++$_i161)
          {
            my $key162 = '';
            my $val163 = '';
            $xfer += $input->readString(\$key162);
            $xfer += $input->readString(\$val163);
            $self->{clientProperties}->{$key162} = $val163;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AdParameters');
  if (defined $self->{clientLanguage}) {
    $xfer += $output->writeFieldBegin('clientLanguage', TType::STRING, 2);
    $xfer += $output->writeString($self->{clientLanguage});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{impressions}) {
    $xfer += $output->writeFieldBegin('impressions', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{impressions}}));
      {
        foreach my $iter164 (@{$self->{impressions}}) 
        {
          $xfer += ${iter164}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{supportHtml}) {
    $xfer += $output->writeFieldBegin('supportHtml', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{supportHtml});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{clientProperties}) {
    $xfer += $output->writeFieldBegin('clientProperties', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{clientProperties}}));
      {
        while( my ($kiter165,$viter166) = each %{$self->{clientProperties}}) 
        {
          $xfer += $output->writeString($kiter165);
          $xfer += $output->writeString($viter166);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteEmailParameters;
use base qw(Class::Accessor);
EDAMNoteStore::NoteEmailParameters->mk_accessors( qw( guid note toAddresses ccAddresses subject message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{guid} = undef;
  $self->{note} = undef;
  $self->{toAddresses} = undef;
  $self->{ccAddresses} = undef;
  $self->{subject} = undef;
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{note}) {
      $self->{note} = $vals->{note};
    }
    if (defined $vals->{toAddresses}) {
      $self->{toAddresses} = $vals->{toAddresses};
    }
    if (defined $vals->{ccAddresses}) {
      $self->{ccAddresses} = $vals->{ccAddresses};
    }
    if (defined $vals->{subject}) {
      $self->{subject} = $vals->{subject};
    }
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteEmailParameters';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{note} = new EDAMTypes::Note();
        $xfer += $self->{note}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size167 = 0;
          $self->{toAddresses} = [];
          my $_etype170 = 0;
          $xfer += $input->readListBegin(\$_etype170, \$_size167);
          for (my $_i171 = 0; $_i171 < $_size167; ++$_i171)
          {
            my $elem172 = undef;
            $xfer += $input->readString(\$elem172);
            push(@{$self->{toAddresses}},$elem172);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size173 = 0;
          $self->{ccAddresses} = [];
          my $_etype176 = 0;
          $xfer += $input->readListBegin(\$_etype176, \$_size173);
          for (my $_i177 = 0; $_i177 < $_size173; ++$_i177)
          {
            my $elem178 = undef;
            $xfer += $input->readString(\$elem178);
            push(@{$self->{ccAddresses}},$elem178);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{subject});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteEmailParameters');
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 1);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{note}) {
    $xfer += $output->writeFieldBegin('note', TType::STRUCT, 2);
    $xfer += $self->{note}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{toAddresses}) {
    $xfer += $output->writeFieldBegin('toAddresses', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{toAddresses}}));
      {
        foreach my $iter179 (@{$self->{toAddresses}}) 
        {
          $xfer += $output->writeString($iter179);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ccAddresses}) {
    $xfer += $output->writeFieldBegin('ccAddresses', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{ccAddresses}}));
      {
        foreach my $iter180 (@{$self->{ccAddresses}}) 
        {
          $xfer += $output->writeString($iter180);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{subject}) {
    $xfer += $output->writeFieldBegin('subject', TType::STRING, 5);
    $xfer += $output->writeString($self->{subject});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 6);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteVersionId;
use base qw(Class::Accessor);
EDAMNoteStore::NoteVersionId->mk_accessors( qw( updateSequenceNum updated saved title ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{updateSequenceNum} = undef;
  $self->{updated} = undef;
  $self->{saved} = undef;
  $self->{title} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{updateSequenceNum}) {
      $self->{updateSequenceNum} = $vals->{updateSequenceNum};
    }
    if (defined $vals->{updated}) {
      $self->{updated} = $vals->{updated};
    }
    if (defined $vals->{saved}) {
      $self->{saved} = $vals->{saved};
    }
    if (defined $vals->{title}) {
      $self->{title} = $vals->{title};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteVersionId';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{updateSequenceNum});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{updated});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{saved});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{title});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteVersionId');
  if (defined $self->{updateSequenceNum}) {
    $xfer += $output->writeFieldBegin('updateSequenceNum', TType::I32, 1);
    $xfer += $output->writeI32($self->{updateSequenceNum});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updated}) {
    $xfer += $output->writeFieldBegin('updated', TType::I64, 2);
    $xfer += $output->writeI64($self->{updated});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{saved}) {
    $xfer += $output->writeFieldBegin('saved', TType::I64, 3);
    $xfer += $output->writeI64($self->{saved});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{title}) {
    $xfer += $output->writeFieldBegin('title', TType::STRING, 4);
    $xfer += $output->writeString($self->{title});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;

#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use EDAMUserStore::Types;

# HELPER FUNCTIONS AND STRUCTURES

package EDAMUserStore::UserStore_checkVersion_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_checkVersion_args->mk_accessors( qw( clientName edamVersionMajor edamVersionMinor ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{clientName} = undef;
  $self->{edamVersionMajor} = 1;
  $self->{edamVersionMinor} = 25;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{clientName}) {
      $self->{clientName} = $vals->{clientName};
    }
    if (defined $vals->{edamVersionMajor}) {
      $self->{edamVersionMajor} = $vals->{edamVersionMajor};
    }
    if (defined $vals->{edamVersionMinor}) {
      $self->{edamVersionMinor} = $vals->{edamVersionMinor};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_checkVersion_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{clientName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{edamVersionMajor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{edamVersionMinor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_checkVersion_args');
  if (defined $self->{clientName}) {
    $xfer += $output->writeFieldBegin('clientName', TType::STRING, 1);
    $xfer += $output->writeString($self->{clientName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{edamVersionMajor}) {
    $xfer += $output->writeFieldBegin('edamVersionMajor', TType::I16, 2);
    $xfer += $output->writeI16($self->{edamVersionMajor});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{edamVersionMinor}) {
    $xfer += $output->writeFieldBegin('edamVersionMinor', TType::I16, 3);
    $xfer += $output->writeI16($self->{edamVersionMinor});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_checkVersion_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_checkVersion_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_checkVersion_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_checkVersion_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_getBootstrapInfo_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_getBootstrapInfo_args->mk_accessors( qw( locale ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{locale} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{locale}) {
      $self->{locale} = $vals->{locale};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_getBootstrapInfo_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locale});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_getBootstrapInfo_args');
  if (defined $self->{locale}) {
    $xfer += $output->writeFieldBegin('locale', TType::STRING, 1);
    $xfer += $output->writeString($self->{locale});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_getBootstrapInfo_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_getBootstrapInfo_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_getBootstrapInfo_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMUserStore::BootstrapInfo();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_getBootstrapInfo_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_authenticate_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_authenticate_args->mk_accessors( qw( username password consumerKey consumerSecret supportsTwoFactor ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  $self->{password} = undef;
  $self->{consumerKey} = undef;
  $self->{consumerSecret} = undef;
  $self->{supportsTwoFactor} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{password}) {
      $self->{password} = $vals->{password};
    }
    if (defined $vals->{consumerKey}) {
      $self->{consumerKey} = $vals->{consumerKey};
    }
    if (defined $vals->{consumerSecret}) {
      $self->{consumerSecret} = $vals->{consumerSecret};
    }
    if (defined $vals->{supportsTwoFactor}) {
      $self->{supportsTwoFactor} = $vals->{supportsTwoFactor};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_authenticate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{password});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{consumerKey});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{consumerSecret});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{supportsTwoFactor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_authenticate_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{password}) {
    $xfer += $output->writeFieldBegin('password', TType::STRING, 2);
    $xfer += $output->writeString($self->{password});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consumerKey}) {
    $xfer += $output->writeFieldBegin('consumerKey', TType::STRING, 3);
    $xfer += $output->writeString($self->{consumerKey});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consumerSecret}) {
    $xfer += $output->writeFieldBegin('consumerSecret', TType::STRING, 4);
    $xfer += $output->writeString($self->{consumerSecret});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{supportsTwoFactor}) {
    $xfer += $output->writeFieldBegin('supportsTwoFactor', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{supportsTwoFactor});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_authenticate_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_authenticate_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_authenticate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMUserStore::AuthenticationResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_authenticate_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_authenticateLongSession_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_authenticateLongSession_args->mk_accessors( qw( username password consumerKey consumerSecret deviceIdentifier deviceDescription supportsTwoFactor ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  $self->{password} = undef;
  $self->{consumerKey} = undef;
  $self->{consumerSecret} = undef;
  $self->{deviceIdentifier} = undef;
  $self->{deviceDescription} = undef;
  $self->{supportsTwoFactor} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{password}) {
      $self->{password} = $vals->{password};
    }
    if (defined $vals->{consumerKey}) {
      $self->{consumerKey} = $vals->{consumerKey};
    }
    if (defined $vals->{consumerSecret}) {
      $self->{consumerSecret} = $vals->{consumerSecret};
    }
    if (defined $vals->{deviceIdentifier}) {
      $self->{deviceIdentifier} = $vals->{deviceIdentifier};
    }
    if (defined $vals->{deviceDescription}) {
      $self->{deviceDescription} = $vals->{deviceDescription};
    }
    if (defined $vals->{supportsTwoFactor}) {
      $self->{supportsTwoFactor} = $vals->{supportsTwoFactor};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_authenticateLongSession_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{password});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{consumerKey});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{consumerSecret});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{deviceIdentifier});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{deviceDescription});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{supportsTwoFactor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_authenticateLongSession_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{password}) {
    $xfer += $output->writeFieldBegin('password', TType::STRING, 2);
    $xfer += $output->writeString($self->{password});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consumerKey}) {
    $xfer += $output->writeFieldBegin('consumerKey', TType::STRING, 3);
    $xfer += $output->writeString($self->{consumerKey});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consumerSecret}) {
    $xfer += $output->writeFieldBegin('consumerSecret', TType::STRING, 4);
    $xfer += $output->writeString($self->{consumerSecret});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deviceIdentifier}) {
    $xfer += $output->writeFieldBegin('deviceIdentifier', TType::STRING, 5);
    $xfer += $output->writeString($self->{deviceIdentifier});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deviceDescription}) {
    $xfer += $output->writeFieldBegin('deviceDescription', TType::STRING, 6);
    $xfer += $output->writeString($self->{deviceDescription});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{supportsTwoFactor}) {
    $xfer += $output->writeFieldBegin('supportsTwoFactor', TType::BOOL, 7);
    $xfer += $output->writeBool($self->{supportsTwoFactor});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_authenticateLongSession_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_authenticateLongSession_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_authenticateLongSession_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMUserStore::AuthenticationResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_authenticateLongSession_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_completeTwoFactorAuthentication_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_completeTwoFactorAuthentication_args->mk_accessors( qw( authenticationToken oneTimeCode deviceIdentifier deviceDescription ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  $self->{oneTimeCode} = undef;
  $self->{deviceIdentifier} = undef;
  $self->{deviceDescription} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
    if (defined $vals->{oneTimeCode}) {
      $self->{oneTimeCode} = $vals->{oneTimeCode};
    }
    if (defined $vals->{deviceIdentifier}) {
      $self->{deviceIdentifier} = $vals->{deviceIdentifier};
    }
    if (defined $vals->{deviceDescription}) {
      $self->{deviceDescription} = $vals->{deviceDescription};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_completeTwoFactorAuthentication_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{oneTimeCode});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{deviceIdentifier});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{deviceDescription});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_completeTwoFactorAuthentication_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{oneTimeCode}) {
    $xfer += $output->writeFieldBegin('oneTimeCode', TType::STRING, 2);
    $xfer += $output->writeString($self->{oneTimeCode});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deviceIdentifier}) {
    $xfer += $output->writeFieldBegin('deviceIdentifier', TType::STRING, 3);
    $xfer += $output->writeString($self->{deviceIdentifier});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deviceDescription}) {
    $xfer += $output->writeFieldBegin('deviceDescription', TType::STRING, 4);
    $xfer += $output->writeString($self->{deviceDescription});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_completeTwoFactorAuthentication_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_completeTwoFactorAuthentication_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_completeTwoFactorAuthentication_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMUserStore::AuthenticationResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_completeTwoFactorAuthentication_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_revokeLongSession_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_revokeLongSession_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_revokeLongSession_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_revokeLongSession_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_revokeLongSession_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_revokeLongSession_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_revokeLongSession_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_revokeLongSession_result');
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_authenticateToBusiness_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_authenticateToBusiness_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_authenticateToBusiness_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_authenticateToBusiness_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_authenticateToBusiness_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_authenticateToBusiness_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_authenticateToBusiness_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMUserStore::AuthenticationResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_authenticateToBusiness_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_refreshAuthentication_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_refreshAuthentication_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_refreshAuthentication_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_refreshAuthentication_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_refreshAuthentication_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_refreshAuthentication_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_refreshAuthentication_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMUserStore::AuthenticationResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_refreshAuthentication_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_getUser_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_getUser_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_getUser_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_getUser_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_getUser_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_getUser_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_getUser_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::User();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_getUser_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_getPublicUserInfo_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_getPublicUserInfo_args->mk_accessors( qw( username ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_getPublicUserInfo_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_getPublicUserInfo_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_getPublicUserInfo_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_getPublicUserInfo_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{notFoundException} = undef;
  $self->{systemException} = undef;
  $self->{userException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{notFoundException}) {
      $self->{notFoundException} = $vals->{notFoundException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_getPublicUserInfo_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMUserStore::PublicUserInfo();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{notFoundException} = new EDAMErrors::EDAMNotFoundException();
        $xfer += $self->{notFoundException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_getPublicUserInfo_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notFoundException}) {
    $xfer += $output->writeFieldBegin('notFoundException', TType::STRUCT, 1);
    $xfer += $self->{notFoundException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 3);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_getPremiumInfo_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_getPremiumInfo_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_getPremiumInfo_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_getPremiumInfo_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_getPremiumInfo_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_getPremiumInfo_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_getPremiumInfo_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new EDAMTypes::PremiumInfo();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_getPremiumInfo_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_getNoteStoreUrl_args;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_getNoteStoreUrl_args->mk_accessors( qw( authenticationToken ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authenticationToken} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authenticationToken}) {
      $self->{authenticationToken} = $vals->{authenticationToken};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_getNoteStoreUrl_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{authenticationToken});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_getNoteStoreUrl_args');
  if (defined $self->{authenticationToken}) {
    $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
    $xfer += $output->writeString($self->{authenticationToken});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStore_getNoteStoreUrl_result;
use base qw(Class::Accessor);
EDAMUserStore::UserStore_getNoteStoreUrl_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{userException} = undef;
  $self->{systemException} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{userException}) {
      $self->{userException} = $vals->{userException};
    }
    if (defined $vals->{systemException}) {
      $self->{systemException} = $vals->{systemException};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserStore_getNoteStoreUrl_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userException} = new EDAMErrors::EDAMUserException();
        $xfer += $self->{userException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{systemException} = new EDAMErrors::EDAMSystemException();
        $xfer += $self->{systemException}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserStore_getNoteStoreUrl_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userException}) {
    $xfer += $output->writeFieldBegin('userException', TType::STRUCT, 1);
    $xfer += $self->{userException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{systemException}) {
    $xfer += $output->writeFieldBegin('systemException', TType::STRUCT, 2);
    $xfer += $self->{systemException}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMUserStore::UserStoreIf;

use strict;


sub checkVersion{
  my $self = shift;
  my $clientName = shift;
  my $edamVersionMajor = shift;
  my $edamVersionMinor = shift;

  die 'implement interface';
}

sub getBootstrapInfo{
  my $self = shift;
  my $locale = shift;

  die 'implement interface';
}

sub authenticate{
  my $self = shift;
  my $username = shift;
  my $password = shift;
  my $consumerKey = shift;
  my $consumerSecret = shift;
  my $supportsTwoFactor = shift;

  die 'implement interface';
}

sub authenticateLongSession{
  my $self = shift;
  my $username = shift;
  my $password = shift;
  my $consumerKey = shift;
  my $consumerSecret = shift;
  my $deviceIdentifier = shift;
  my $deviceDescription = shift;
  my $supportsTwoFactor = shift;

  die 'implement interface';
}

sub completeTwoFactorAuthentication{
  my $self = shift;
  my $authenticationToken = shift;
  my $oneTimeCode = shift;
  my $deviceIdentifier = shift;
  my $deviceDescription = shift;

  die 'implement interface';
}

sub revokeLongSession{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub authenticateToBusiness{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub refreshAuthentication{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub getUser{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub getPublicUserInfo{
  my $self = shift;
  my $username = shift;

  die 'implement interface';
}

sub getPremiumInfo{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

sub getNoteStoreUrl{
  my $self = shift;
  my $authenticationToken = shift;

  die 'implement interface';
}

package EDAMUserStore::UserStoreRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub checkVersion{
  my ($self, $request) = @_;

  my $clientName = ($request->{'clientName'}) ? $request->{'clientName'} : undef;
  my $edamVersionMajor = ($request->{'edamVersionMajor'}) ? $request->{'edamVersionMajor'} : undef;
  my $edamVersionMinor = ($request->{'edamVersionMinor'}) ? $request->{'edamVersionMinor'} : undef;
  return $self->{impl}->checkVersion($clientName, $edamVersionMajor, $edamVersionMinor);
}

sub getBootstrapInfo{
  my ($self, $request) = @_;

  my $locale = ($request->{'locale'}) ? $request->{'locale'} : undef;
  return $self->{impl}->getBootstrapInfo($locale);
}

sub authenticate{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $password = ($request->{'password'}) ? $request->{'password'} : undef;
  my $consumerKey = ($request->{'consumerKey'}) ? $request->{'consumerKey'} : undef;
  my $consumerSecret = ($request->{'consumerSecret'}) ? $request->{'consumerSecret'} : undef;
  my $supportsTwoFactor = ($request->{'supportsTwoFactor'}) ? $request->{'supportsTwoFactor'} : undef;
  return $self->{impl}->authenticate($username, $password, $consumerKey, $consumerSecret, $supportsTwoFactor);
}

sub authenticateLongSession{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $password = ($request->{'password'}) ? $request->{'password'} : undef;
  my $consumerKey = ($request->{'consumerKey'}) ? $request->{'consumerKey'} : undef;
  my $consumerSecret = ($request->{'consumerSecret'}) ? $request->{'consumerSecret'} : undef;
  my $deviceIdentifier = ($request->{'deviceIdentifier'}) ? $request->{'deviceIdentifier'} : undef;
  my $deviceDescription = ($request->{'deviceDescription'}) ? $request->{'deviceDescription'} : undef;
  my $supportsTwoFactor = ($request->{'supportsTwoFactor'}) ? $request->{'supportsTwoFactor'} : undef;
  return $self->{impl}->authenticateLongSession($username, $password, $consumerKey, $consumerSecret, $deviceIdentifier, $deviceDescription, $supportsTwoFactor);
}

sub completeTwoFactorAuthentication{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  my $oneTimeCode = ($request->{'oneTimeCode'}) ? $request->{'oneTimeCode'} : undef;
  my $deviceIdentifier = ($request->{'deviceIdentifier'}) ? $request->{'deviceIdentifier'} : undef;
  my $deviceDescription = ($request->{'deviceDescription'}) ? $request->{'deviceDescription'} : undef;
  return $self->{impl}->completeTwoFactorAuthentication($authenticationToken, $oneTimeCode, $deviceIdentifier, $deviceDescription);
}

sub revokeLongSession{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->revokeLongSession($authenticationToken);
}

sub authenticateToBusiness{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->authenticateToBusiness($authenticationToken);
}

sub refreshAuthentication{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->refreshAuthentication($authenticationToken);
}

sub getUser{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->getUser($authenticationToken);
}

sub getPublicUserInfo{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  return $self->{impl}->getPublicUserInfo($username);
}

sub getPremiumInfo{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->getPremiumInfo($authenticationToken);
}

sub getNoteStoreUrl{
  my ($self, $request) = @_;

  my $authenticationToken = ($request->{'authenticationToken'}) ? $request->{'authenticationToken'} : undef;
  return $self->{impl}->getNoteStoreUrl($authenticationToken);
}

package EDAMUserStore::UserStoreClient;


use base qw(EDAMUserStore::UserStoreIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub checkVersion{
  my $self = shift;
  my $clientName = shift;
  my $edamVersionMajor = shift;
  my $edamVersionMinor = shift;

    $self->send_checkVersion($clientName, $edamVersionMajor, $edamVersionMinor);
  return $self->recv_checkVersion();
}

sub send_checkVersion{
  my $self = shift;
  my $clientName = shift;
  my $edamVersionMajor = shift;
  my $edamVersionMinor = shift;

  $self->{output}->writeMessageBegin('checkVersion', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_checkVersion_args();
  $args->{clientName} = $clientName;
  $args->{edamVersionMajor} = $edamVersionMajor;
  $args->{edamVersionMinor} = $edamVersionMinor;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_checkVersion{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_checkVersion_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "checkVersion failed: unknown result";
}
sub getBootstrapInfo{
  my $self = shift;
  my $locale = shift;

    $self->send_getBootstrapInfo($locale);
  return $self->recv_getBootstrapInfo();
}

sub send_getBootstrapInfo{
  my $self = shift;
  my $locale = shift;

  $self->{output}->writeMessageBegin('getBootstrapInfo', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_getBootstrapInfo_args();
  $args->{locale} = $locale;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getBootstrapInfo{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_getBootstrapInfo_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getBootstrapInfo failed: unknown result";
}
sub authenticate{
  my $self = shift;
  my $username = shift;
  my $password = shift;
  my $consumerKey = shift;
  my $consumerSecret = shift;
  my $supportsTwoFactor = shift;

    $self->send_authenticate($username, $password, $consumerKey, $consumerSecret, $supportsTwoFactor);
  return $self->recv_authenticate();
}

sub send_authenticate{
  my $self = shift;
  my $username = shift;
  my $password = shift;
  my $consumerKey = shift;
  my $consumerSecret = shift;
  my $supportsTwoFactor = shift;

  $self->{output}->writeMessageBegin('authenticate', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_authenticate_args();
  $args->{username} = $username;
  $args->{password} = $password;
  $args->{consumerKey} = $consumerKey;
  $args->{consumerSecret} = $consumerSecret;
  $args->{supportsTwoFactor} = $supportsTwoFactor;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_authenticate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_authenticate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "authenticate failed: unknown result";
}
sub authenticateLongSession{
  my $self = shift;
  my $username = shift;
  my $password = shift;
  my $consumerKey = shift;
  my $consumerSecret = shift;
  my $deviceIdentifier = shift;
  my $deviceDescription = shift;
  my $supportsTwoFactor = shift;

    $self->send_authenticateLongSession($username, $password, $consumerKey, $consumerSecret, $deviceIdentifier, $deviceDescription, $supportsTwoFactor);
  return $self->recv_authenticateLongSession();
}

sub send_authenticateLongSession{
  my $self = shift;
  my $username = shift;
  my $password = shift;
  my $consumerKey = shift;
  my $consumerSecret = shift;
  my $deviceIdentifier = shift;
  my $deviceDescription = shift;
  my $supportsTwoFactor = shift;

  $self->{output}->writeMessageBegin('authenticateLongSession', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_authenticateLongSession_args();
  $args->{username} = $username;
  $args->{password} = $password;
  $args->{consumerKey} = $consumerKey;
  $args->{consumerSecret} = $consumerSecret;
  $args->{deviceIdentifier} = $deviceIdentifier;
  $args->{deviceDescription} = $deviceDescription;
  $args->{supportsTwoFactor} = $supportsTwoFactor;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_authenticateLongSession{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_authenticateLongSession_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "authenticateLongSession failed: unknown result";
}
sub completeTwoFactorAuthentication{
  my $self = shift;
  my $authenticationToken = shift;
  my $oneTimeCode = shift;
  my $deviceIdentifier = shift;
  my $deviceDescription = shift;

    $self->send_completeTwoFactorAuthentication($authenticationToken, $oneTimeCode, $deviceIdentifier, $deviceDescription);
  return $self->recv_completeTwoFactorAuthentication();
}

sub send_completeTwoFactorAuthentication{
  my $self = shift;
  my $authenticationToken = shift;
  my $oneTimeCode = shift;
  my $deviceIdentifier = shift;
  my $deviceDescription = shift;

  $self->{output}->writeMessageBegin('completeTwoFactorAuthentication', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_completeTwoFactorAuthentication_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->{oneTimeCode} = $oneTimeCode;
  $args->{deviceIdentifier} = $deviceIdentifier;
  $args->{deviceDescription} = $deviceDescription;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_completeTwoFactorAuthentication{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_completeTwoFactorAuthentication_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "completeTwoFactorAuthentication failed: unknown result";
}
sub revokeLongSession{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_revokeLongSession($authenticationToken);
  $self->recv_revokeLongSession();
}

sub send_revokeLongSession{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('revokeLongSession', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_revokeLongSession_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_revokeLongSession{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_revokeLongSession_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  return;
}
sub authenticateToBusiness{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_authenticateToBusiness($authenticationToken);
  return $self->recv_authenticateToBusiness();
}

sub send_authenticateToBusiness{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('authenticateToBusiness', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_authenticateToBusiness_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_authenticateToBusiness{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_authenticateToBusiness_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "authenticateToBusiness failed: unknown result";
}
sub refreshAuthentication{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_refreshAuthentication($authenticationToken);
  return $self->recv_refreshAuthentication();
}

sub send_refreshAuthentication{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('refreshAuthentication', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_refreshAuthentication_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_refreshAuthentication{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_refreshAuthentication_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "refreshAuthentication failed: unknown result";
}
sub getUser{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_getUser($authenticationToken);
  return $self->recv_getUser();
}

sub send_getUser{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('getUser', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_getUser_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getUser{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_getUser_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "getUser failed: unknown result";
}
sub getPublicUserInfo{
  my $self = shift;
  my $username = shift;

    $self->send_getPublicUserInfo($username);
  return $self->recv_getPublicUserInfo();
}

sub send_getPublicUserInfo{
  my $self = shift;
  my $username = shift;

  $self->{output}->writeMessageBegin('getPublicUserInfo', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_getPublicUserInfo_args();
  $args->{username} = $username;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getPublicUserInfo{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_getPublicUserInfo_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{notFoundException}) {
    die $result->{notFoundException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  die "getPublicUserInfo failed: unknown result";
}
sub getPremiumInfo{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_getPremiumInfo($authenticationToken);
  return $self->recv_getPremiumInfo();
}

sub send_getPremiumInfo{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('getPremiumInfo', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_getPremiumInfo_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getPremiumInfo{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_getPremiumInfo_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "getPremiumInfo failed: unknown result";
}
sub getNoteStoreUrl{
  my $self = shift;
  my $authenticationToken = shift;

    $self->send_getNoteStoreUrl($authenticationToken);
  return $self->recv_getNoteStoreUrl();
}

sub send_getNoteStoreUrl{
  my $self = shift;
  my $authenticationToken = shift;

  $self->{output}->writeMessageBegin('getNoteStoreUrl', TMessageType::CALL, $self->{seqid});
  my $args = new EDAMUserStore::UserStore_getNoteStoreUrl_args();
  $args->{authenticationToken} = $authenticationToken;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getNoteStoreUrl{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new EDAMUserStore::UserStore_getNoteStoreUrl_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{userException}) {
    die $result->{userException};
  }
  if (defined $result->{systemException}) {
    die $result->{systemException};
  }
  die "getNoteStoreUrl failed: unknown result";
}
package EDAMUserStore::UserStoreProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_checkVersion {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_checkVersion_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_checkVersion_result();
    $result->{success} = $self->{handler}->checkVersion($args->clientName, $args->edamVersionMajor, $args->edamVersionMinor);
    $output->writeMessageBegin('checkVersion', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getBootstrapInfo {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_getBootstrapInfo_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_getBootstrapInfo_result();
    $result->{success} = $self->{handler}->getBootstrapInfo($args->locale);
    $output->writeMessageBegin('getBootstrapInfo', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_authenticate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_authenticate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_authenticate_result();
    eval {
      $result->{success} = $self->{handler}->authenticate($args->username, $args->password, $args->consumerKey, $args->consumerSecret, $args->supportsTwoFactor);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('authenticate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_authenticateLongSession {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_authenticateLongSession_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_authenticateLongSession_result();
    eval {
      $result->{success} = $self->{handler}->authenticateLongSession($args->username, $args->password, $args->consumerKey, $args->consumerSecret, $args->deviceIdentifier, $args->deviceDescription, $args->supportsTwoFactor);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('authenticateLongSession', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_completeTwoFactorAuthentication {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_completeTwoFactorAuthentication_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_completeTwoFactorAuthentication_result();
    eval {
      $result->{success} = $self->{handler}->completeTwoFactorAuthentication($args->authenticationToken, $args->oneTimeCode, $args->deviceIdentifier, $args->deviceDescription);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('completeTwoFactorAuthentication', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_revokeLongSession {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_revokeLongSession_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_revokeLongSession_result();
    eval {
      $self->{handler}->revokeLongSession($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('revokeLongSession', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_authenticateToBusiness {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_authenticateToBusiness_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_authenticateToBusiness_result();
    eval {
      $result->{success} = $self->{handler}->authenticateToBusiness($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('authenticateToBusiness', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_refreshAuthentication {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_refreshAuthentication_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_refreshAuthentication_result();
    eval {
      $result->{success} = $self->{handler}->refreshAuthentication($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('refreshAuthentication', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getUser {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_getUser_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_getUser_result();
    eval {
      $result->{success} = $self->{handler}->getUser($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('getUser', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getPublicUserInfo {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_getPublicUserInfo_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_getPublicUserInfo_result();
    eval {
      $result->{success} = $self->{handler}->getPublicUserInfo($args->username);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMNotFoundException') ){ 
      $result->{notFoundException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
    }
    $output->writeMessageBegin('getPublicUserInfo', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getPremiumInfo {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_getPremiumInfo_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_getPremiumInfo_result();
    eval {
      $result->{success} = $self->{handler}->getPremiumInfo($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('getPremiumInfo', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getNoteStoreUrl {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new EDAMUserStore::UserStore_getNoteStoreUrl_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new EDAMUserStore::UserStore_getNoteStoreUrl_result();
    eval {
      $result->{success} = $self->{handler}->getNoteStoreUrl($args->authenticationToken);
    }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMUserException') ){ 
      $result->{userException} = $@;
        }; if( UNIVERSAL::isa($@,'EDAMErrors::EDAMSystemException') ){ 
      $result->{systemException} = $@;
    }
    $output->writeMessageBegin('getNoteStoreUrl', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
